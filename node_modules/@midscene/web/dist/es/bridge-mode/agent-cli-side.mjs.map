{"version":3,"file":"bridge-mode/agent-cli-side.mjs","sources":["webpack://@midscene/web/./src/bridge-mode/agent-cli-side.ts"],"sourcesContent":["import { Agent, type AgentOpt } from '@midscene/core/agent';\nimport { assert } from '@midscene/shared/utils';\nimport { commonWebActionsForWebPage } from '../web-page';\nimport type { KeyboardAction, MouseAction } from '../web-page';\nimport {\n  type BridgeConnectTabOptions,\n  BridgeEvent,\n  BridgePageType,\n  DefaultBridgeServerPort,\n  KeyboardEvent,\n  MouseEvent,\n} from './common';\nimport { BridgeServer } from './io-server';\nimport type { ExtensionBridgePageBrowserSide } from './page-browser-side';\n\ninterface ChromeExtensionPageCliSide extends ExtensionBridgePageBrowserSide {\n  showStatusMessage: (message: string) => Promise<void>;\n}\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// actually, this is a proxy to the page in browser side\nexport const getBridgePageInCliSide = (\n  timeout?: number | false,\n  closeConflictServer?: boolean,\n): ChromeExtensionPageCliSide => {\n  const server = new BridgeServer(\n    DefaultBridgeServerPort,\n    undefined,\n    undefined,\n    closeConflictServer,\n  );\n  server.listen({\n    timeout,\n  });\n  const bridgeCaller = (method: string) => {\n    return async (...args: any[]) => {\n      const response = await server.call(method, args);\n      return response;\n    };\n  };\n  const page = {\n    showStatusMessage: async (message: string) => {\n      await server.call(BridgeEvent.UpdateAgentStatus, [message]);\n    },\n  };\n\n  const proxyPage = new Proxy(page, {\n    get(target, prop, receiver) {\n      assert(typeof prop === 'string', 'prop must be a string');\n\n      if (prop === 'toJSON') {\n        return () => {\n          return {\n            interfaceType: BridgePageType,\n          };\n        };\n      }\n\n      if (prop === 'getContext') {\n        return undefined;\n      }\n\n      if (prop === 'interfaceType') {\n        return BridgePageType;\n      }\n\n      if (prop === 'actionSpace') {\n        return () => commonWebActionsForWebPage(proxyPage);\n      }\n\n      if (Object.keys(page).includes(prop)) {\n        return page[prop as keyof typeof page];\n      }\n\n      if (prop === 'mouse') {\n        const mouse: MouseAction = {\n          click: bridgeCaller(MouseEvent.Click),\n          wheel: bridgeCaller(MouseEvent.Wheel),\n          move: bridgeCaller(MouseEvent.Move),\n          drag: bridgeCaller(MouseEvent.Drag),\n        };\n        return mouse;\n      }\n\n      if (prop === 'keyboard') {\n        const keyboard: KeyboardAction = {\n          type: bridgeCaller(KeyboardEvent.Type),\n          press: bridgeCaller(KeyboardEvent.Press),\n        };\n        return keyboard;\n      }\n\n      if (prop === 'destroy') {\n        return async (...args: any[]) => {\n          try {\n            const caller = bridgeCaller('destroy');\n            await caller(...args);\n          } catch (e) {\n            // console.error('error calling destroy', e);\n          }\n          return server.close();\n        };\n      }\n\n      return bridgeCaller(prop);\n    },\n  }) as ChromeExtensionPageCliSide;\n\n  return proxyPage;\n};\n\nexport class AgentOverChromeBridge extends Agent<ChromeExtensionPageCliSide> {\n  private destroyAfterDisconnectFlag?: boolean;\n\n  constructor(\n    opts?: AgentOpt & {\n      closeNewTabsAfterDisconnect?: boolean;\n      serverListeningTimeout?: number | false;\n      closeConflictServer?: boolean;\n    },\n  ) {\n    const page = getBridgePageInCliSide(opts?.serverListeningTimeout);\n    super(\n      page,\n      Object.assign(opts || {}, {\n        onTaskStartTip: (tip: string) => {\n          this.page.showStatusMessage(tip);\n        },\n      }),\n    );\n    this.destroyAfterDisconnectFlag = opts?.closeNewTabsAfterDisconnect;\n  }\n\n  async setDestroyOptionsAfterConnect() {\n    if (this.destroyAfterDisconnectFlag) {\n      this.page.setDestroyOptions({\n        closeTab: true,\n      });\n    }\n  }\n\n  async connectNewTabWithUrl(url: string, options?: BridgeConnectTabOptions) {\n    await this.page.connectNewTabWithUrl(url, options);\n    await sleep(500);\n    await this.setDestroyOptionsAfterConnect();\n  }\n\n  async getBrowserTabList() {\n    return await this.page.getBrowserTabList();\n  }\n\n  async setActiveTabId(tabId: string) {\n    return await this.page.setActiveTabId(Number.parseInt(tabId));\n  }\n\n  async connectCurrentTab(options?: BridgeConnectTabOptions) {\n    await this.page.connectCurrentTab(options);\n    await sleep(500);\n    await this.setDestroyOptionsAfterConnect();\n  }\n\n  async aiAction(prompt: string, options?: any) {\n    if (options) {\n      console.warn(\n        'the `options` parameter of aiAction is not supported in cli side',\n      );\n    }\n    return await super.aiAction(prompt);\n  }\n\n  async destroy(closeNewTabsAfterDisconnect?: boolean) {\n    if (typeof closeNewTabsAfterDisconnect === 'boolean') {\n      await this.page.setDestroyOptions({\n        closeTab: closeNewTabsAfterDisconnect,\n      });\n    }\n    await super.destroy();\n  }\n}\n"],"names":["sleep","ms","Promise","resolve","setTimeout","getBridgePageInCliSide","timeout","closeConflictServer","server","BridgeServer","DefaultBridgeServerPort","undefined","bridgeCaller","method","args","response","page","message","BridgeEvent","proxyPage","Proxy","target","prop","receiver","assert","BridgePageType","commonWebActionsForWebPage","Object","mouse","MouseEvent","keyboard","KeyboardEvent","caller","e","AgentOverChromeBridge","Agent","url","options","tabId","Number","prompt","console","closeNewTabsAfterDisconnect","opts","tip"],"mappings":"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"}