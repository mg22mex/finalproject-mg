{"version":3,"file":"bridge-mode/io-server.mjs","sources":["webpack://@midscene/web/./src/bridge-mode/io-server.ts"],"sourcesContent":["import { sleep } from '@midscene/core/utils';\nimport { logMsg } from '@midscene/shared/utils';\nimport { Server, type Socket as ServerSocket } from 'socket.io';\nimport { io as ClientIO } from 'socket.io-client';\n\nimport {\n  type BridgeCall,\n  type BridgeCallResponse,\n  BridgeCallTimeout,\n  type BridgeConnectedEventPayload,\n  BridgeErrorCodeNoClientConnected,\n  BridgeEvent,\n  BridgeSignalKill,\n  DefaultBridgeServerPort,\n} from './common';\n\ndeclare const __VERSION__: string;\n\nexport const killRunningServer = async (port?: number) => {\n  try {\n    const client = ClientIO(\n      `ws://localhost:${port || DefaultBridgeServerPort}`,\n      {\n        query: {\n          [BridgeSignalKill]: 1,\n        },\n      },\n    );\n    await sleep(100);\n    await client.close();\n  } catch (e) {\n    // console.error('failed to kill port', e);\n  }\n};\n\n// ws server, this is where the request is sent\nexport class BridgeServer {\n  private callId = 0;\n  private io: Server | null = null;\n  private socket: ServerSocket | null = null;\n  private listeningTimeoutId: NodeJS.Timeout | null = null;\n  private listeningTimerFlag = false;\n  private connectionTipTimer: NodeJS.Timeout | null = null;\n  public calls: Record<string, BridgeCall> = {};\n\n  private connectionLost = false;\n  private connectionLostReason = '';\n\n  constructor(\n    public port: number,\n    public onConnect?: () => void,\n    public onDisconnect?: (reason: string) => void,\n    public closeConflictServer?: boolean,\n  ) {}\n\n  async listen(\n    opts: {\n      timeout?: number | false;\n    } = {},\n  ): Promise<void> {\n    const { timeout = 30000 } = opts;\n\n    if (this.closeConflictServer) {\n      await killRunningServer(this.port);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.listeningTimerFlag) {\n        return reject(new Error('already listening'));\n      }\n      this.listeningTimerFlag = true;\n\n      this.listeningTimeoutId = timeout\n        ? setTimeout(() => {\n            reject(\n              new Error(\n                `no extension connected after ${timeout}ms (${BridgeErrorCodeNoClientConnected})`,\n              ),\n            );\n          }, timeout)\n        : null;\n\n      this.connectionTipTimer =\n        !timeout || timeout > 3000\n          ? setTimeout(() => {\n              logMsg('waiting for bridge to connect...');\n            }, 2000)\n          : null;\n      this.io = new Server(this.port, {\n        maxHttpBufferSize: 100 * 1024 * 1024, // 100MB\n      });\n\n      // Listen for the native HTTP server 'listening' event\n      this.io.httpServer.once('listening', () => {\n        resolve();\n      });\n\n      this.io.httpServer.once('error', (err: Error) => {\n        reject(new Error(`Bridge Listening Error: ${err.message}`));\n      });\n\n      this.io.use((socket, next) => {\n        if (this.socket) {\n          next(new Error('server already connected by another client'));\n        }\n        next();\n      });\n\n      this.io.on('connection', (socket) => {\n        // check the connection url\n        const url = socket.handshake.url;\n        if (url.includes(BridgeSignalKill)) {\n          console.warn('kill signal received, closing bridge server');\n          return this.close();\n        }\n\n        this.connectionLost = false;\n        this.connectionLostReason = '';\n        this.listeningTimeoutId && clearTimeout(this.listeningTimeoutId);\n        this.listeningTimeoutId = null;\n        this.connectionTipTimer && clearTimeout(this.connectionTipTimer);\n        this.connectionTipTimer = null;\n        if (this.socket) {\n          socket.emit(BridgeEvent.Refused);\n          // close the socket\n          socket.disconnect();\n\n          return reject(\n            new Error('server already connected by another client'),\n          );\n        }\n\n        try {\n          logMsg('one client connected');\n          this.socket = socket;\n\n          const clientVersion = socket.handshake.query.version;\n          logMsg(\n            `Bridge connected, cli-side version v${__VERSION__}, browser-side version v${clientVersion}`,\n          );\n\n          socket.on(BridgeEvent.CallResponse, (params: BridgeCallResponse) => {\n            const id = params.id;\n            const response = params.response;\n            const error = params.error;\n\n            this.triggerCallResponseCallback(id, error, response);\n          });\n\n          socket.on('disconnect', (reason: string) => {\n            this.connectionLost = true;\n            this.connectionLostReason = reason;\n\n            try {\n              this.io?.close();\n            } catch (e) {\n              // ignore\n            }\n\n            // flush all pending calls as error\n            for (const id in this.calls) {\n              const call = this.calls[id];\n\n              if (!call.responseTime) {\n                const errorMessage = this.connectionLostErrorMsg();\n                this.triggerCallResponseCallback(\n                  id,\n                  new Error(errorMessage),\n                  null,\n                );\n              }\n            }\n\n            this.onDisconnect?.(reason);\n          });\n\n          setTimeout(() => {\n            this.onConnect?.();\n\n            const payload = {\n              version: __VERSION__,\n            } as BridgeConnectedEventPayload;\n            socket.emit(BridgeEvent.Connected, payload);\n            Promise.resolve().then(() => {\n              for (const id in this.calls) {\n                if (this.calls[id].callTime === 0) {\n                  this.emitCall(id);\n                }\n              }\n            });\n          }, 0);\n        } catch (e) {\n          console.error('failed to handle connection event', e);\n          reject(e);\n        }\n      });\n\n      this.io.on('close', () => {\n        this.close();\n      });\n    });\n  }\n\n  private connectionLostErrorMsg = () => {\n    return `Connection lost, reason: ${this.connectionLostReason}`;\n  };\n\n  private async triggerCallResponseCallback(\n    id: string | number,\n    error: Error | null,\n    response: any,\n  ) {\n    const call = this.calls[id];\n    if (!call) {\n      throw new Error(`call ${id} not found`);\n    }\n    call.error = error || undefined;\n    call.response = response;\n    call.responseTime = Date.now();\n\n    call.callback(call.error, response);\n  }\n\n  private async emitCall(id: string) {\n    const call = this.calls[id];\n    if (!call) {\n      throw new Error(`call ${id} not found`);\n    }\n\n    if (this.connectionLost) {\n      const message = `Connection lost, reason: ${this.connectionLostReason}`;\n      call.callback(new Error(message), null);\n      return;\n    }\n\n    if (this.socket) {\n      this.socket.emit(BridgeEvent.Call, {\n        id,\n        method: call.method,\n        args: call.args,\n      });\n      call.callTime = Date.now();\n    }\n  }\n\n  async call<T = any>(\n    method: string,\n    args: any[],\n    timeout = BridgeCallTimeout,\n  ): Promise<T> {\n    const id = `${this.callId++}`;\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        logMsg(`bridge call timeout, id=${id}, method=${method}, args=`, args);\n        this.calls[id].error = new Error(\n          `Bridge call timeout after ${timeout}ms: ${method}`,\n        );\n        reject(this.calls[id].error);\n      }, timeout);\n\n      this.calls[id] = {\n        method,\n        args,\n        response: null,\n        callTime: 0,\n        responseTime: 0,\n        callback: (error: Error | undefined, response: any) => {\n          clearTimeout(timeoutId);\n          if (error) {\n            reject(error);\n          } else {\n            resolve(response);\n          }\n        },\n      };\n\n      this.emitCall(id);\n    });\n  }\n\n  // do NOT restart after close\n  async close() {\n    this.listeningTimeoutId && clearTimeout(this.listeningTimeoutId);\n    this.connectionTipTimer && clearTimeout(this.connectionTipTimer);\n    const closeProcess = this.io?.close();\n    this.io = null;\n\n    return closeProcess;\n  }\n}\n"],"names":["killRunningServer","port","client","ClientIO","DefaultBridgeServerPort","BridgeSignalKill","sleep","e","BridgeServer","opts","timeout","Promise","resolve","reject","Error","setTimeout","BridgeErrorCodeNoClientConnected","logMsg","Server","err","socket","next","url","console","clearTimeout","BridgeEvent","clientVersion","params","id","response","error","reason","_this","_this_io","call","errorMessage","payload","__VERSION__","undefined","Date","message","method","args","BridgeCallTimeout","timeoutId","closeProcess","onConnect","onDisconnect","closeConflictServer"],"mappings":"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"}