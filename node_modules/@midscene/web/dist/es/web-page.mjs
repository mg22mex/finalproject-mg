import node_assert from "node:assert";
import { AbstractInterface, defineActionDragAndDrop, defineActionHover, defineActionInput, defineActionKeyboardPress, defineActionRightClick, defineActionScroll, defineActionTap } from "@midscene/core/device";
import { sleep } from "@midscene/core/utils";
function getKeyCommands(value) {
    const keys = Array.isArray(value) ? value : [
        value
    ];
    return keys.reduce((acc, k)=>{
        const includeMeta = keys.includes('Meta') || keys.includes('Control');
        if (includeMeta && ('a' === k || 'A' === k)) return acc.concat([
            {
                key: k,
                command: 'SelectAll'
            }
        ]);
        if (includeMeta && ('c' === k || 'C' === k)) return acc.concat([
            {
                key: k,
                command: 'Copy'
            }
        ]);
        if (includeMeta && ('v' === k || 'V' === k)) return acc.concat([
            {
                key: k,
                command: 'Paste'
            }
        ]);
        return acc.concat([
            {
                key: k
            }
        ]);
    }, []);
}
class AbstractWebPage extends AbstractInterface {
    get mouse() {
        return {
            click: async (x, y, options)=>{},
            wheel: async (deltaX, deltaY)=>{},
            move: async (x, y)=>{},
            drag: async (from, to)=>{}
        };
    }
    get keyboard() {
        return {
            type: async (text)=>{},
            press: async (action)=>{}
        };
    }
    async clearInput(element) {}
}
const commonWebActionsForWebPage = (page)=>[
        defineActionTap(async (param)=>{
            const element = param.locate;
            node_assert(element, 'Element not found, cannot tap');
            await page.mouse.click(element.center[0], element.center[1], {
                button: 'left'
            });
        }),
        defineActionRightClick(async (param)=>{
            const element = param.locate;
            node_assert(element, 'Element not found, cannot right click');
            await page.mouse.click(element.center[0], element.center[1], {
                button: 'right'
            });
        }),
        defineActionHover(async (param)=>{
            const element = param.locate;
            node_assert(element, 'Element not found, cannot hover');
            await page.mouse.move(element.center[0], element.center[1]);
        }),
        defineActionInput(async (param)=>{
            const element = param.locate;
            if (element) {
                await page.clearInput(element);
                if (!param || !param.value) return;
            }
            await page.keyboard.type(param.value);
        }),
        defineActionKeyboardPress(async (param)=>{
            const element = param.locate;
            if (element) await page.mouse.click(element.center[0], element.center[1], {
                button: 'left'
            });
            const keys = getKeyCommands(param.keyName);
            await page.keyboard.press(keys);
        }),
        defineActionScroll(async (param)=>{
            const element = param.locate;
            const startingPoint = element ? {
                left: element.center[0],
                top: element.center[1]
            } : void 0;
            const scrollToEventName = null == param ? void 0 : param.scrollType;
            if ('untilTop' === scrollToEventName) await page.scrollUntilTop(startingPoint);
            else if ('untilBottom' === scrollToEventName) await page.scrollUntilBottom(startingPoint);
            else if ('untilRight' === scrollToEventName) await page.scrollUntilRight(startingPoint);
            else if ('untilLeft' === scrollToEventName) await page.scrollUntilLeft(startingPoint);
            else if ('once' !== scrollToEventName && scrollToEventName) throw new Error(`Unknown scroll event type: ${scrollToEventName}, param: ${JSON.stringify(param)}`);
            else {
                if ((null == param ? void 0 : param.direction) !== 'down' && param && param.direction) if ('up' === param.direction) await page.scrollUp(param.distance || void 0, startingPoint);
                else if ('left' === param.direction) await page.scrollLeft(param.distance || void 0, startingPoint);
                else if ('right' === param.direction) await page.scrollRight(param.distance || void 0, startingPoint);
                else throw new Error(`Unknown scroll direction: ${param.direction}`);
                else await page.scrollDown((null == param ? void 0 : param.distance) || void 0, startingPoint);
                await sleep(500);
            }
        }),
        defineActionDragAndDrop(async (param)=>{
            const from = param.from;
            const to = param.to;
            node_assert(from, 'missing "from" param for drag and drop');
            node_assert(to, 'missing "to" param for drag and drop');
            await page.mouse.drag({
                x: from.center[0],
                y: from.center[1]
            }, {
                x: to.center[0],
                y: to.center[1]
            });
        })
    ];
export { AbstractWebPage, commonWebActionsForWebPage, getKeyCommands };

//# sourceMappingURL=web-page.mjs.map