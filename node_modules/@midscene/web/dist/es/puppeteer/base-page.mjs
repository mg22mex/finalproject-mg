import { WebPageContextParser } from "../web-element.mjs";
import { sleep } from "@midscene/core/utils";
import { DEFAULT_WAIT_FOR_NAVIGATION_TIMEOUT } from "@midscene/shared/constants";
import { treeToList } from "@midscene/shared/extractor";
import { createImgBase64ByFormat } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { getElementInfosScriptContent, getExtraReturnLogic } from "@midscene/shared/node";
import { assert } from "@midscene/shared/utils";
import { commonWebActionsForWebPage } from "../web-page.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debugPage = getDebug('web:page');
class Page {
    actionSpace() {
        return commonWebActionsForWebPage(this);
    }
    async evaluate(pageFunction, arg) {
        let result;
        debugPage('evaluate function begin');
        this.interfaceType, result = await this.underlyingPage.evaluate(pageFunction, arg);
        debugPage('evaluate function end');
        return result;
    }
    async evaluateJavaScript(script) {
        return this.evaluate(script);
    }
    async waitForNavigation() {
        if (0 === this.waitForNavigationTimeout) return void debugPage('waitForNavigation timeout is 0, skip waiting');
        if ('puppeteer' === this.interfaceType || 'playwright' === this.interfaceType) {
            debugPage('waitForNavigation begin');
            debugPage(`waitForNavigation timeout: ${this.waitForNavigationTimeout}`);
            try {
                await this.underlyingPage.waitForSelector('html', {
                    timeout: this.waitForNavigationTimeout
                });
            } catch (error) {
                console.warn('[midscene:warning] Waiting for the navigation has timed out, but Midscene will continue execution. Please check https://midscenejs.com/faq.html#customize-the-network-timeout for more information on customizing the network timeout');
            }
            debugPage('waitForNavigation end');
        }
    }
    async getElementsInfo() {
        await this.waitForNavigation();
        debugPage('getElementsInfo begin');
        const tree = await this.getElementsNodeTree();
        debugPage('getElementsInfo end');
        return treeToList(tree);
    }
    async getXpathsById(id) {
        const elementInfosScriptContent = getElementInfosScriptContent();
        return this.evaluateJavaScript(`${elementInfosScriptContent}midscene_element_inspector.getXpathsById('${id}')`);
    }
    async getXpathsByPoint(point, isOrderSensitive) {
        const elementInfosScriptContent = getElementInfosScriptContent();
        return this.evaluateJavaScript(`${elementInfosScriptContent}midscene_element_inspector.getXpathsByPoint({left: ${point.left}, top: ${point.top}}, ${isOrderSensitive})`);
    }
    async getElementInfoByXpath(xpath) {
        const elementInfosScriptContent = getElementInfosScriptContent();
        return this.evaluateJavaScript(`${elementInfosScriptContent}midscene_element_inspector.getElementInfoByXpath('${xpath}')`);
    }
    async getElementsNodeTree() {
        await this.waitForNavigation();
        const scripts = await getExtraReturnLogic(true);
        assert(scripts, "scripts should be set before writing report in browser");
        const startTime = Date.now();
        const captureElementSnapshot = await this.evaluate(scripts);
        const endTime = Date.now();
        debugPage(`getElementsNodeTree end, cost: ${endTime - startTime}ms`);
        return captureElementSnapshot;
    }
    async size() {
        if (this.viewportSize) return this.viewportSize;
        const sizeInfo = await this.evaluate(()=>({
                width: document.documentElement.clientWidth,
                height: document.documentElement.clientHeight,
                dpr: window.devicePixelRatio
            }));
        this.viewportSize = sizeInfo;
        return sizeInfo;
    }
    async screenshotBase64() {
        const imgType = 'jpeg';
        const quality = 90;
        await this.waitForNavigation();
        const startTime = Date.now();
        debugPage('screenshotBase64 begin');
        let base64;
        if ('puppeteer' === this.interfaceType) {
            const result = await this.underlyingPage.screenshot({
                type: imgType,
                quality,
                encoding: 'base64'
            });
            base64 = createImgBase64ByFormat(imgType, result);
        } else if ('playwright' === this.interfaceType) {
            const buffer = await this.underlyingPage.screenshot({
                type: imgType,
                quality,
                timeout: 10000
            });
            base64 = createImgBase64ByFormat(imgType, buffer.toString('base64'));
        } else throw new Error('Unsupported page type for screenshot');
        const endTime = Date.now();
        debugPage(`screenshotBase64 end, cost: ${endTime - startTime}ms`);
        return base64;
    }
    async url() {
        return this.underlyingPage.url();
    }
    describe() {
        const url = this.underlyingPage.url();
        return url || '';
    }
    get mouse() {
        return {
            click: async (x, y, options)=>{
                await this.mouse.move(x, y);
                debugPage(`mouse click ${x}, ${y}`);
                this.underlyingPage.mouse.click(x, y, {
                    button: (null == options ? void 0 : options.button) || 'left',
                    count: (null == options ? void 0 : options.count) || 1
                });
            },
            wheel: async (deltaX, deltaY)=>{
                debugPage(`mouse wheel ${deltaX}, ${deltaY}`);
                if ('puppeteer' === this.interfaceType) await this.underlyingPage.mouse.wheel({
                    deltaX,
                    deltaY
                });
                else if ('playwright' === this.interfaceType) await this.underlyingPage.mouse.wheel(deltaX, deltaY);
            },
            move: async (x, y)=>{
                this.everMoved = true;
                debugPage(`mouse move to ${x}, ${y}`);
                return this.underlyingPage.mouse.move(x, y);
            },
            drag: async (from, to)=>{
                debugPage(`begin mouse drag from ${from.x}, ${from.y} to ${to.x}, ${to.y}`);
                await this.underlyingPage.mouse.move(from.x, from.y);
                await sleep(200);
                await this.underlyingPage.mouse.down();
                await sleep(300);
                await this.underlyingPage.mouse.move(to.x, to.y);
                await sleep(500);
                await this.underlyingPage.mouse.up();
                await sleep(200);
                debugPage(`end mouse drag from ${from.x}, ${from.y} to ${to.x}, ${to.y}`);
            }
        };
    }
    get keyboard() {
        return {
            type: async (text)=>{
                debugPage(`keyboard type ${text}`);
                return this.underlyingPage.keyboard.type(text, {
                    delay: 80
                });
            },
            press: async (action)=>{
                const keys = Array.isArray(action) ? action : [
                    action
                ];
                debugPage('keyboard press', keys);
                for (const k of keys){
                    const commands = k.command ? [
                        k.command
                    ] : [];
                    await this.underlyingPage.keyboard.down(k.key, {
                        commands
                    });
                }
                for (const k of [
                    ...keys
                ].reverse())await this.underlyingPage.keyboard.up(k.key);
            },
            down: async (key)=>{
                debugPage(`keyboard down ${key}`);
                this.underlyingPage.keyboard.down(key);
            },
            up: async (key)=>{
                debugPage(`keyboard up ${key}`);
                this.underlyingPage.keyboard.up(key);
            }
        };
    }
    async clearInput(element) {
        if (!element) return void console.warn('No element to clear input');
        const backspace = async ()=>{
            await sleep(100);
            await this.keyboard.press([
                {
                    key: 'Backspace'
                }
            ]);
        };
        const isMac = 'darwin' === process.platform;
        debugPage('clearInput begin');
        if (isMac) {
            if ('puppeteer' === this.interfaceType) {
                await this.mouse.click(element.center[0], element.center[1], {
                    count: 3
                });
                await backspace();
            }
            await this.mouse.click(element.center[0], element.center[1]);
            await this.underlyingPage.keyboard.down('Meta');
            await this.underlyingPage.keyboard.press('a');
            await this.underlyingPage.keyboard.up('Meta');
            await backspace();
        } else {
            await this.mouse.click(element.center[0], element.center[1]);
            await this.underlyingPage.keyboard.down('Control');
            await this.underlyingPage.keyboard.press('a');
            await this.underlyingPage.keyboard.up('Control');
            await backspace();
        }
        debugPage('clearInput end');
    }
    async moveToPointBeforeScroll(point) {
        if (point) await this.mouse.move(point.left, point.top);
        else if (!this.everMoved) {
            const size = await this.size();
            const targetX = Math.floor(size.width / 2);
            const targetY = Math.floor(size.height / 2);
            await this.mouse.move(targetX, targetY);
        }
    }
    async scrollUntilTop(startingPoint) {
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(0, -9999999);
    }
    async scrollUntilBottom(startingPoint) {
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(0, 9999999);
    }
    async scrollUntilLeft(startingPoint) {
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(-9999999, 0);
    }
    async scrollUntilRight(startingPoint) {
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(9999999, 0);
    }
    async scrollUp(distance, startingPoint) {
        const innerHeight = await this.evaluate(()=>window.innerHeight);
        const scrollDistance = distance || 0.7 * innerHeight;
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(0, -scrollDistance);
    }
    async scrollDown(distance, startingPoint) {
        const innerHeight = await this.evaluate(()=>window.innerHeight);
        const scrollDistance = distance || 0.7 * innerHeight;
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(0, scrollDistance);
    }
    async scrollLeft(distance, startingPoint) {
        const innerWidth = await this.evaluate(()=>window.innerWidth);
        const scrollDistance = distance || 0.7 * innerWidth;
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(-scrollDistance, 0);
    }
    async scrollRight(distance, startingPoint) {
        const innerWidth = await this.evaluate(()=>window.innerWidth);
        const scrollDistance = distance || 0.7 * innerWidth;
        await this.moveToPointBeforeScroll(startingPoint);
        return this.mouse.wheel(scrollDistance, 0);
    }
    async navigate(url) {
        debugPage(`navigate to ${url}`);
        if ('puppeteer' === this.interfaceType) await this.underlyingPage.goto(url);
        else if ('playwright' === this.interfaceType) await this.underlyingPage.goto(url);
        else throw new Error('Unsupported page type for navigate');
    }
    async beforeAction() {
        await this.waitForNavigation();
    }
    async destroy() {}
    async getContext() {
        return await WebPageContextParser(this, {});
    }
    constructor(underlyingPage, interfaceType, opts){
        _define_property(this, "underlyingPage", void 0);
        _define_property(this, "waitForNavigationTimeout", void 0);
        _define_property(this, "viewportSize", void 0);
        _define_property(this, "interfaceType", void 0);
        _define_property(this, "everMoved", false);
        this.underlyingPage = underlyingPage;
        this.interfaceType = interfaceType;
        this.waitForNavigationTimeout = (null == opts ? void 0 : opts.waitForNavigationTimeout) ?? DEFAULT_WAIT_FOR_NAVIGATION_TIMEOUT;
    }
}
function forceClosePopup(page, debugProfile) {
    page.on('popup', async (popup)=>{
        if (!popup) return void console.warn('got a popup event, but the popup is not ready yet, skip');
        const url = await popup.url();
        console.log(`Popup opened: ${url}`);
        if (popup.isClosed()) debugProfile(`popup is already closed, skip close ${url}`);
        else try {
            await popup.close();
        } catch (error) {
            debugProfile(`failed to close popup ${url}, error: ${error}`);
        }
        if (page.isClosed()) debugProfile(`page is already closed, skip goto ${url}`);
        else try {
            await page.goto(url);
        } catch (error) {
            debugProfile(`failed to goto ${url}, error: ${error}`);
        }
    });
}
export { Page, debugPage, forceClosePopup };

//# sourceMappingURL=base-page.mjs.map