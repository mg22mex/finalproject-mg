import { assert } from "@midscene/shared/utils";
import { callToGetJSONObject } from "./service-caller/index.mjs";
import { NodeType } from "@midscene/shared/constants";
import { getModelName, vlLocateMode } from "@midscene/shared/env";
import { treeToList } from "@midscene/shared/extractor";
import { compositeElementInfoImg } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { z } from "zod";
var common_AIActionType = /*#__PURE__*/ function(AIActionType) {
    AIActionType[AIActionType["ASSERT"] = 0] = "ASSERT";
    AIActionType[AIActionType["INSPECT_ELEMENT"] = 1] = "INSPECT_ELEMENT";
    AIActionType[AIActionType["EXTRACT_DATA"] = 2] = "EXTRACT_DATA";
    AIActionType[AIActionType["PLAN"] = 3] = "PLAN";
    AIActionType[AIActionType["DESCRIBE_ELEMENT"] = 4] = "DESCRIBE_ELEMENT";
    return AIActionType;
}({});
async function callAiFn(msgs, AIActionTypeValue, modelPreferences) {
    const jsonObject = await callToGetJSONObject(msgs, AIActionTypeValue, modelPreferences);
    return {
        content: jsonObject.content,
        usage: jsonObject.usage
    };
}
const defaultBboxSize = 20;
const debugInspectUtils = getDebug('ai:common');
function fillBboxParam(locate, width, height, modelPreferences) {
    if (locate.bbox_2d && !(null == locate ? void 0 : locate.bbox)) {
        locate.bbox = locate.bbox_2d;
        delete locate.bbox_2d;
    }
    if (null == locate ? void 0 : locate.bbox) locate.bbox = adaptBbox(locate.bbox, width, height, modelPreferences);
    return locate;
}
function adaptQwenBbox(bbox) {
    if (bbox.length < 2) {
        const msg = `invalid bbox data for qwen-vl mode: ${JSON.stringify(bbox)} `;
        throw new Error(msg);
    }
    const result = [
        Math.round(bbox[0]),
        Math.round(bbox[1]),
        'number' == typeof bbox[2] ? Math.round(bbox[2]) : Math.round(bbox[0] + defaultBboxSize),
        'number' == typeof bbox[3] ? Math.round(bbox[3]) : Math.round(bbox[1] + defaultBboxSize)
    ];
    return result;
}
function adaptDoubaoBbox(bbox, width, height) {
    assert(width > 0 && height > 0, 'width and height must be greater than 0 in doubao mode');
    if ('string' == typeof bbox) {
        assert(/^(\d+)\s(\d+)\s(\d+)\s(\d+)$/.test(bbox.trim()), `invalid bbox data string for doubao-vision mode: ${bbox}`);
        const splitted = bbox.split(' ');
        if (4 === splitted.length) return [
            Math.round(Number(splitted[0]) * width / 1000),
            Math.round(Number(splitted[1]) * height / 1000),
            Math.round(Number(splitted[2]) * width / 1000),
            Math.round(Number(splitted[3]) * height / 1000)
        ];
        throw new Error(`invalid bbox data string for doubao-vision mode: ${bbox}`);
    }
    if (Array.isArray(bbox) && Array.isArray(bbox[0])) bbox = bbox[0];
    let bboxList = [];
    if (Array.isArray(bbox) && 'string' == typeof bbox[0]) bbox.forEach((item)=>{
        if ('string' == typeof item && item.includes(',')) {
            const [x, y] = item.split(',');
            bboxList.push(Number(x.trim()), Number(y.trim()));
        } else if ('string' == typeof item && item.includes(' ')) {
            const [x, y] = item.split(' ');
            bboxList.push(Number(x.trim()), Number(y.trim()));
        } else bboxList.push(Number(item));
    });
    else bboxList = bbox;
    if (4 === bboxList.length || 5 === bboxList.length) return [
        Math.round(bboxList[0] * width / 1000),
        Math.round(bboxList[1] * height / 1000),
        Math.round(bboxList[2] * width / 1000),
        Math.round(bboxList[3] * height / 1000)
    ];
    if (6 === bboxList.length || 2 === bboxList.length || 3 === bboxList.length || 7 === bboxList.length) return [
        Math.max(0, Math.round(bboxList[0] * width / 1000) - defaultBboxSize / 2),
        Math.max(0, Math.round(bboxList[1] * height / 1000) - defaultBboxSize / 2),
        Math.min(width, Math.round(bboxList[0] * width / 1000) + defaultBboxSize / 2),
        Math.min(height, Math.round(bboxList[1] * height / 1000) + defaultBboxSize / 2)
    ];
    if (8 === bbox.length) return [
        Math.round(bboxList[0] * width / 1000),
        Math.round(bboxList[1] * height / 1000),
        Math.round(bboxList[4] * width / 1000),
        Math.round(bboxList[5] * height / 1000)
    ];
    const msg = `invalid bbox data for doubao-vision mode: ${JSON.stringify(bbox)} `;
    throw new Error(msg);
}
function adaptBbox(bbox, width, height, modelPreferences) {
    if ('doubao-vision' === vlLocateMode(modelPreferences) || 'vlm-ui-tars' === vlLocateMode(modelPreferences)) return adaptDoubaoBbox(bbox, width, height);
    if ('gemini' === vlLocateMode(modelPreferences)) return adaptGeminiBbox(bbox, width, height);
    return adaptQwenBbox(bbox);
}
function adaptGeminiBbox(bbox, width, height) {
    const left = Math.round(bbox[1] * width / 1000);
    const top = Math.round(bbox[0] * height / 1000);
    const right = Math.round(bbox[3] * width / 1000);
    const bottom = Math.round(bbox[2] * height / 1000);
    return [
        left,
        top,
        right,
        bottom
    ];
}
function adaptBboxToRect(bbox, width, height, modelPreferences, offsetX = 0, offsetY = 0) {
    debugInspectUtils('adaptBboxToRect', bbox, width, height, offsetX, offsetY);
    const [left, top, right, bottom] = adaptBbox(bbox, width, height, modelPreferences);
    const rect = {
        left: left + offsetX,
        top: top + offsetY,
        width: right - left,
        height: bottom - top
    };
    debugInspectUtils('adaptBboxToRect, result=', rect);
    return rect;
}
let warned = false;
function warnGPT4oSizeLimit(size, modelPreferences) {
    var _getModelName;
    if (warned) return;
    if (null == (_getModelName = getModelName(modelPreferences)) ? void 0 : _getModelName.toLowerCase().includes('gpt-4o')) {
        const warningMsg = `GPT-4o has a maximum image input size of 2000x768 or 768x2000, but got ${size.width}x${size.height}. Please set your interface to a smaller resolution. Otherwise, the result may be inaccurate.`;
        if (Math.max(size.width, size.height) > 2000 || Math.min(size.width, size.height) > 768) {
            console.warn(warningMsg);
            warned = true;
        }
    } else if (size.width > 1800 || size.height > 1800) {
        console.warn(`The image size seems too large (${size.width}x${size.height}). It may lead to more token usage, slower response, and inaccurate result.`);
        warned = true;
    }
}
function mergeRects(rects) {
    const minLeft = Math.min(...rects.map((r)=>r.left));
    const minTop = Math.min(...rects.map((r)=>r.top));
    const maxRight = Math.max(...rects.map((r)=>r.left + r.width));
    const maxBottom = Math.max(...rects.map((r)=>r.top + r.height));
    return {
        left: minLeft,
        top: minTop,
        width: maxRight - minLeft,
        height: maxBottom - minTop
    };
}
function expandSearchArea(rect, screenSize, modelPreferences) {
    const minEdgeSize = 'doubao-vision' === vlLocateMode(modelPreferences) ? 500 : 300;
    const defaultPadding = 160;
    const paddingSizeHorizontal = rect.width < minEdgeSize ? Math.ceil((minEdgeSize - rect.width) / 2) : defaultPadding;
    const paddingSizeVertical = rect.height < minEdgeSize ? Math.ceil((minEdgeSize - rect.height) / 2) : defaultPadding;
    rect.left = Math.max(0, rect.left - paddingSizeHorizontal);
    rect.width = Math.min(rect.width + 2 * paddingSizeHorizontal, screenSize.width - rect.left);
    rect.top = Math.max(0, rect.top - paddingSizeVertical);
    rect.height = Math.min(rect.height + 2 * paddingSizeVertical, screenSize.height - rect.top);
    return rect;
}
async function markupImageForLLM(screenshotBase64, tree, size) {
    const elementsInfo = treeToList(tree);
    const elementsPositionInfoWithoutText = elementsInfo.filter((elementInfo)=>{
        if (elementInfo.attributes.nodeType === NodeType.TEXT) return false;
        return true;
    });
    const imagePayload = await compositeElementInfoImg({
        inputImgBase64: screenshotBase64,
        elementsPositionInfo: elementsPositionInfoWithoutText,
        size
    });
    return imagePayload;
}
function buildYamlFlowFromPlans(plans, actionSpace, sleep) {
    const flow = [];
    for (const plan of plans){
        const verb = plan.type;
        const action = actionSpace.find((action)=>action.name === verb);
        if (!action) {
            console.warn(`Cannot convert action ${verb} to yaml flow. Will ignore it.`);
            continue;
        }
        const flowKey = action.interfaceAlias || verb;
        const flowParam = action.paramSchema ? dumpActionParam(plan.param || {}, action.paramSchema) : {};
        const flowItem = {
            [flowKey]: '',
            ...flowParam
        };
        flow.push(flowItem);
    }
    if (sleep) flow.push({
        sleep
    });
    return flow;
}
const PointSchema = z.object({
    left: z.number(),
    top: z.number()
});
const SizeSchema = z.object({
    width: z.number(),
    height: z.number(),
    dpr: z.number().optional()
});
const RectSchema = PointSchema.and(SizeSchema).and(z.object({
    zoom: z.number().optional()
}));
const TMultimodalPromptSchema = z.object({
    images: z.array(z.object({
        name: z.string(),
        url: z.string()
    })).optional(),
    convertHttpImage2Base64: z.boolean().optional()
});
const TUserPromptSchema = z.union([
    z.string(),
    z.object({
        prompt: z.string()
    }).and(TMultimodalPromptSchema.partial())
]);
const locateFieldFlagName = 'midscene_location_field_flag';
const MidsceneLocationResult = z.object({
    [locateFieldFlagName]: z.literal(true),
    prompt: TUserPromptSchema,
    deepThink: z.boolean().optional(),
    cacheable: z.boolean().optional(),
    xpath: z.boolean().optional(),
    center: z.tuple([
        z.number(),
        z.number()
    ]),
    rect: RectSchema
}).passthrough();
const getMidsceneLocationSchema = ()=>MidsceneLocationResult;
const ifMidsceneLocatorField = (field)=>{
    var _actualField__def, _actualField__def1;
    let actualField = field;
    if ((null == (_actualField__def = actualField._def) ? void 0 : _actualField__def.typeName) === 'ZodOptional') actualField = actualField._def.innerType;
    if ((null == (_actualField__def1 = actualField._def) ? void 0 : _actualField__def1.typeName) === 'ZodObject') {
        const shape = actualField._def.shape();
        return locateFieldFlagName in shape;
    }
    return false;
};
const dumpMidsceneLocatorField = (field)=>{
    assert(ifMidsceneLocatorField(field), 'field is not a midscene locator field');
    if ('string' == typeof field) return field;
    if (field && 'object' == typeof field && field.prompt) {
        if ('string' == typeof field.prompt) return field.prompt;
        if ('object' == typeof field.prompt && field.prompt.prompt) return field.prompt.prompt;
    }
    return String(field);
};
const findAllMidsceneLocatorField = (zodType, requiredOnly)=>{
    var _zodObject__def;
    if (!zodType) return [];
    const zodObject = zodType;
    if ((null == (_zodObject__def = zodObject._def) ? void 0 : _zodObject__def.typeName) === 'ZodObject' && zodObject.shape) {
        const keys = Object.keys(zodObject.shape);
        return keys.filter((key)=>{
            const field = zodObject.shape[key];
            if (!ifMidsceneLocatorField(field)) return false;
            if (requiredOnly) {
                var _field__def;
                return (null == (_field__def = field._def) ? void 0 : _field__def.typeName) !== 'ZodOptional';
            }
            return true;
        });
    }
    return [];
};
const dumpActionParam = (jsonObject, zodSchema)=>{
    const locatorFields = findAllMidsceneLocatorField(zodSchema);
    const result = {
        ...jsonObject
    };
    for (const fieldName of locatorFields){
        const fieldValue = result[fieldName];
        if (fieldValue) {
            if ('string' == typeof fieldValue) result[fieldName] = fieldValue;
            else if ('object' == typeof fieldValue) {
                if (fieldValue.prompt) {
                    if ('string' == typeof fieldValue.prompt) result[fieldName] = fieldValue.prompt;
                    else if ('object' == typeof fieldValue.prompt && fieldValue.prompt.prompt) result[fieldName] = fieldValue.prompt.prompt;
                }
            }
        }
    }
    return result;
};
const loadActionParam = (jsonObject, zodSchema)=>{
    const locatorFields = findAllMidsceneLocatorField(zodSchema);
    const result = {
        ...jsonObject
    };
    for (const fieldName of locatorFields){
        const fieldValue = result[fieldName];
        if (fieldValue && 'string' == typeof fieldValue) result[fieldName] = {
            [locateFieldFlagName]: true,
            prompt: fieldValue
        };
    }
    return result;
};
export { common_AIActionType as AIActionType, PointSchema, RectSchema, SizeSchema, TMultimodalPromptSchema, TUserPromptSchema, adaptBbox, adaptBboxToRect, adaptDoubaoBbox, adaptGeminiBbox, adaptQwenBbox, buildYamlFlowFromPlans, callAiFn, dumpActionParam, dumpMidsceneLocatorField, expandSearchArea, fillBboxParam, findAllMidsceneLocatorField, getMidsceneLocationSchema, ifMidsceneLocatorField, loadActionParam, markupImageForLLM, mergeRects, warnGPT4oSizeLimit };

//# sourceMappingURL=common.mjs.map