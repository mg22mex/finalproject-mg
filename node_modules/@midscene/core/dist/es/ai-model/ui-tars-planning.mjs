import { UITarsModelVersion, uiTarsModelVersion, vlLocateMode } from "@midscene/shared/env";
import { resizeImgBase64 } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { transformHotkeyInput } from "@midscene/shared/us-keyboard-layout";
import { assert } from "@midscene/shared/utils";
import { actionParser } from "@ui-tars/action-parser";
import { AIActionType } from "./common.mjs";
import { getSummary, getUiTarsPlanningPrompt } from "./prompt/ui-tars-planning.mjs";
import { call } from "./service-caller/index.mjs";
const debug = getDebug('ui-tars-planning');
const bboxSize = 10;
const pointToBbox = (point, width, height)=>[
        Math.round(Math.max(point.x - bboxSize / 2, 0)),
        Math.round(Math.max(point.y - bboxSize / 2, 0)),
        Math.round(Math.min(point.x + bboxSize / 2, width)),
        Math.round(Math.min(point.y + bboxSize / 2, height))
    ];
async function vlmPlanning(options) {
    const { conversationHistory, userInstruction, size, modelPreferences } = options;
    const systemPrompt = getUiTarsPlanningPrompt() + userInstruction;
    const res = await call([
        {
            role: 'user',
            content: systemPrompt
        },
        ...conversationHistory
    ], AIActionType.INSPECT_ELEMENT, modelPreferences);
    const convertedText = convertBboxToCoordinates(res.content);
    const modelVer = uiTarsModelVersion(modelPreferences);
    const { parsed } = actionParser({
        prediction: convertedText,
        factor: [
            1000,
            1000
        ],
        screenContext: {
            width: size.width,
            height: size.height
        },
        modelVer: modelVer || void 0
    });
    debug('ui-tars modelVer', modelVer, ', parsed', JSON.stringify(parsed));
    const transformActions = [];
    parsed.forEach((action)=>{
        if ('click' === action.action_type) {
            assert(action.action_inputs.start_box, 'start_box is required');
            const point = getPoint(action.action_inputs.start_box, size);
            transformActions.push({
                type: 'Tap',
                param: {
                    locate: {
                        prompt: action.thought || '',
                        bbox: pointToBbox({
                            x: point[0],
                            y: point[1]
                        }, size.width, size.height)
                    }
                }
            });
        } else if ('drag' === action.action_type) {
            assert(action.action_inputs.start_box, 'start_box is required');
            assert(action.action_inputs.end_box, 'end_box is required');
            const startPoint = getPoint(action.action_inputs.start_box, size);
            const endPoint = getPoint(action.action_inputs.end_box, size);
            transformActions.push({
                type: 'DragAndDrop',
                param: {
                    from: {
                        prompt: action.thought || '',
                        bbox: pointToBbox({
                            x: startPoint[0],
                            y: startPoint[1]
                        }, size.width, size.height)
                    },
                    to: {
                        prompt: action.thought || '',
                        bbox: pointToBbox({
                            x: endPoint[0],
                            y: endPoint[1]
                        }, size.width, size.height)
                    }
                },
                thought: action.thought || ''
            });
        } else if ('type' === action.action_type) transformActions.push({
            type: 'Input',
            param: {
                value: action.action_inputs.content
            },
            thought: action.thought || ''
        });
        else if ('scroll' === action.action_type) transformActions.push({
            type: 'Scroll',
            param: {
                direction: action.action_inputs.direction
            },
            thought: action.thought || ''
        });
        else if ('finished' === action.action_type) transformActions.push({
            type: 'Finished',
            param: {},
            thought: action.thought || ''
        });
        else if ('hotkey' === action.action_type) if (action.action_inputs.key) {
            const keys = transformHotkeyInput(action.action_inputs.key);
            transformActions.push({
                type: 'KeyboardPress',
                param: {
                    keyName: keys
                },
                thought: action.thought || ''
            });
        } else console.warn('No key found in action: hotkey. Will not perform action.');
        else if ('wait' === action.action_type) transformActions.push({
            type: 'Sleep',
            param: {
                timeMs: 1000
            },
            thought: action.thought || ''
        });
    });
    if (0 === transformActions.length) throw new Error(`No actions found, response: ${res.content}`, {
        cause: {
            prediction: res.content,
            parsed
        }
    });
    debug('transformActions', JSON.stringify(transformActions, null, 2));
    return {
        actions: transformActions,
        actionsFromModel: parsed,
        action_summary: getSummary(res.content),
        usage: res.usage,
        rawResponse: JSON.stringify(res.content, void 0, 2)
    };
}
function convertBboxToCoordinates(text) {
    const pattern = /<bbox>(\d+)\s+(\d+)\s+(\d+)\s+(\d+)<\/bbox>/g;
    function replaceMatch(match, x1, y1, x2, y2) {
        const x1Num = Number.parseInt(x1, 10);
        const y1Num = Number.parseInt(y1, 10);
        const x2Num = Number.parseInt(x2, 10);
        const y2Num = Number.parseInt(y2, 10);
        const x = Math.floor((x1Num + x2Num) / 2);
        const y = Math.floor((y1Num + y2Num) / 2);
        return `(${x},${y})`;
    }
    const cleanedText = text.replace(/\[EOS\]/g, '');
    return cleanedText.replace(pattern, replaceMatch).trim();
}
function getPoint(startBox, size) {
    const [x, y] = JSON.parse(startBox);
    return [
        x * size.width,
        y * size.height
    ];
}
async function resizeImageForUiTars(imageBase64, size, modelPreferences) {
    if ('vlm-ui-tars' === vlLocateMode(modelPreferences) && uiTarsModelVersion(modelPreferences) === UITarsModelVersion.V1_5) {
        debug('ui-tars-v1.5, will check image size', size);
        const currentPixels = size.width * size.height;
        const maxPixels = 12845056;
        if (currentPixels > maxPixels) {
            const resizeFactor = Math.sqrt(maxPixels / currentPixels);
            const newWidth = Math.floor(size.width * resizeFactor);
            const newHeight = Math.floor(size.height * resizeFactor);
            debug('resize image for ui-tars, new width: %s, new height: %s', newWidth, newHeight);
            const resizedImage = await resizeImgBase64(imageBase64, {
                width: newWidth,
                height: newHeight
            });
            return resizedImage;
        }
    }
    return imageBase64;
}
export { resizeImageForUiTars, vlmPlanning };

//# sourceMappingURL=ui-tars-planning.mjs.map