{"version":3,"file":"agent/tasks.mjs","sources":["webpack://@midscene/core/./src/agent/tasks.ts"],"sourcesContent":["import {\n  type ChatCompletionMessageParam,\n  elementByPositionWithElementInfo,\n  findAllMidsceneLocatorField,\n  resizeImageForUiTars,\n  vlmPlanning,\n} from '@/ai-model';\nimport type { AbstractInterface } from '@/device';\nimport {\n  type AIUsageInfo,\n  type BaseElement,\n  type DetailedLocateParam,\n  type DumpSubscriber,\n  type ExecutionRecorderItem,\n  type ExecutionTaskActionApply,\n  type ExecutionTaskApply,\n  type ExecutionTaskHitBy,\n  type ExecutionTaskInsightLocateApply,\n  type ExecutionTaskInsightQueryApply,\n  type ExecutionTaskPlanning,\n  type ExecutionTaskPlanningApply,\n  type ExecutionTaskProgressOptions,\n  Executor,\n  type ExecutorContext,\n  type Insight,\n  type InsightDump,\n  type InsightExtractOption,\n  type InsightExtractParam,\n  type InterfaceType,\n  type LocateResultElement,\n  type MidsceneYamlFlowItem,\n  type PlanningAIResponse,\n  type PlanningAction,\n  type PlanningActionParamError,\n  type PlanningActionParamSleep,\n  type PlanningActionParamWaitFor,\n  type PlanningLocateParam,\n  type TMultimodalPrompt,\n  type TUserPrompt,\n  type UIContext,\n  plan,\n} from '@/index';\nimport { sleep } from '@/utils';\nimport { NodeType } from '@midscene/shared/constants';\nimport {\n  type IModelPreferences,\n  MIDSCENE_REPLANNING_CYCLE_LIMIT,\n  globalConfigManager,\n} from '@midscene/shared/env';\nimport { getDebug } from '@midscene/shared/logger';\nimport { assert } from '@midscene/shared/utils';\nimport type { TaskCache } from './task-cache';\nimport { taskTitleStr } from './ui-utils';\nimport {\n  matchElementFromCache,\n  matchElementFromPlan,\n  parsePrompt,\n} from './utils';\n\ninterface ExecutionResult<OutputType = any> {\n  output: OutputType;\n  thought?: string;\n  executor: Executor;\n}\n\nconst debug = getDebug('device-task-executor');\nconst defaultReplanningCycleLimit = 10;\n\nexport function locatePlanForLocate(param: string | DetailedLocateParam) {\n  const locate = typeof param === 'string' ? { prompt: param } : param;\n  const locatePlan: PlanningAction<PlanningLocateParam> = {\n    type: 'Locate',\n    locate,\n    param: locate,\n    thought: '',\n  };\n  return locatePlan;\n}\n\nexport class TaskExecutor {\n  interface: AbstractInterface;\n\n  insight: Insight;\n\n  taskCache?: TaskCache;\n\n  conversationHistory: ChatCompletionMessageParam[] = [];\n\n  onTaskStartCallback?: ExecutionTaskProgressOptions['onTaskStart'];\n\n  // @deprecated use .interface instead\n  get page() {\n    return this.interface;\n  }\n\n  constructor(\n    interfaceInstance: AbstractInterface,\n    insight: Insight,\n    opts: {\n      taskCache?: TaskCache;\n      onTaskStart?: ExecutionTaskProgressOptions['onTaskStart'];\n    },\n  ) {\n    this.interface = interfaceInstance;\n    this.insight = insight;\n    this.taskCache = opts.taskCache;\n    this.onTaskStartCallback = opts?.onTaskStart;\n  }\n\n  private async recordScreenshot(timing: ExecutionRecorderItem['timing']) {\n    const base64 = await this.interface.screenshotBase64();\n    const item: ExecutionRecorderItem = {\n      type: 'screenshot',\n      ts: Date.now(),\n      screenshot: base64,\n      timing,\n    };\n    return item;\n  }\n\n  private async getElementXpath(\n    uiContext: UIContext<BaseElement>,\n    element: LocateResultElement,\n  ): Promise<string[] | undefined> {\n    if (!(this.interface as any).getXpathsByPoint) {\n      debug('getXpathsByPoint is not supported for this interface');\n      return undefined;\n    }\n\n    let elementId = element?.id;\n    if (element?.isOrderSensitive !== undefined) {\n      const xpaths = await (this.interface as any).getXpathsByPoint(\n        {\n          left: element.center[0],\n          top: element.center[1],\n        },\n        element?.isOrderSensitive,\n      );\n\n      return xpaths;\n    }\n\n    // find the nearest xpath for the element\n    if (element?.attributes?.nodeType === NodeType.POSITION) {\n      await this.insight.contextRetrieverFn('locate');\n      const info = elementByPositionWithElementInfo(\n        uiContext.tree,\n        {\n          x: element.center[0],\n          y: element.center[1],\n        },\n        {\n          requireStrictDistance: false,\n          filterPositionElements: true,\n        },\n      );\n      if (info?.id) {\n        elementId = info.id;\n      } else {\n        debug(\n          'no element id found for position node, will not update cache',\n          element,\n        );\n      }\n    }\n\n    if (!elementId) {\n      return undefined;\n    }\n    try {\n      const result = await (this.interface as any).getXpathsById(elementId);\n      return result;\n    } catch (error) {\n      debug('getXpathsById error: ', error);\n    }\n  }\n\n  private prependExecutorWithScreenshot(\n    taskApply: ExecutionTaskApply,\n    appendAfterExecution = false,\n  ): ExecutionTaskApply {\n    const taskWithScreenshot: ExecutionTaskApply = {\n      ...taskApply,\n      executor: async (param, context, ...args) => {\n        const recorder: ExecutionRecorderItem[] = [];\n        const { task } = context;\n        // set the recorder before executor in case of error\n        task.recorder = recorder;\n        const shot = await this.recordScreenshot(`before ${task.type}`);\n        recorder.push(shot);\n        const result = await taskApply.executor(param, context, ...args);\n        if (taskApply.type === 'Action') {\n          await Promise.all([\n            (async () => {\n              await sleep(100);\n              if (this.interface.beforeAction) {\n                debug('will call \"beforeAction\" for interface');\n                await this.interface.beforeAction();\n              }\n            })(),\n            sleep(200),\n          ]);\n        }\n        if (appendAfterExecution) {\n          const shot2 = await this.recordScreenshot('after Action');\n          recorder.push(shot2);\n        }\n        return result;\n      },\n    };\n    return taskWithScreenshot;\n  }\n\n  public async convertPlanToExecutable(plans: PlanningAction[]) {\n    const tasks: ExecutionTaskApply[] = [];\n\n    const taskForLocatePlan = (\n      plan: PlanningAction<PlanningLocateParam>,\n      detailedLocateParam: DetailedLocateParam | string,\n      onResult?: (result: LocateResultElement) => void,\n    ): ExecutionTaskInsightLocateApply => {\n      if (typeof detailedLocateParam === 'string') {\n        detailedLocateParam = {\n          prompt: detailedLocateParam,\n        };\n      }\n      const taskFind: ExecutionTaskInsightLocateApply = {\n        type: 'Insight',\n        subType: 'Locate',\n        param: detailedLocateParam,\n        thought: plan.thought,\n        executor: async (param, taskContext) => {\n          const { task } = taskContext;\n          assert(\n            param?.prompt || param?.id || param?.bbox,\n            `No prompt or id or position or bbox to locate, param=${JSON.stringify(\n              param,\n            )}`,\n          );\n          let insightDump: InsightDump | undefined;\n          let usage: AIUsageInfo | undefined;\n          const dumpCollector: DumpSubscriber = (dump) => {\n            insightDump = dump;\n            usage = dump?.taskInfo?.usage;\n\n            task.log = {\n              dump: insightDump,\n            };\n\n            task.usage = usage;\n          };\n          this.insight.onceDumpUpdatedFn = dumpCollector;\n          const shotTime = Date.now();\n\n          // Get context through contextRetrieverFn which handles frozen context\n          const uiContext = await this.insight.contextRetrieverFn('locate');\n          task.uiContext = uiContext;\n\n          const recordItem: ExecutionRecorderItem = {\n            type: 'screenshot',\n            ts: shotTime,\n            screenshot: uiContext.screenshotBase64,\n            timing: 'before Insight',\n          };\n          task.recorder = [recordItem];\n\n          // try matching xpath\n          const elementFromXpath =\n            param.xpath && (this.interface as any).getElementInfoByXpath\n              ? await (this.interface as any).getElementInfoByXpath(param.xpath)\n              : undefined;\n          const userExpectedPathHitFlag = !!elementFromXpath;\n\n          // try matching cache\n          const cachePrompt = param.prompt;\n          const locateCacheRecord =\n            this.taskCache?.matchLocateCache(cachePrompt);\n          const xpaths = locateCacheRecord?.cacheContent?.xpaths;\n          const elementFromCache = userExpectedPathHitFlag\n            ? null\n            : await matchElementFromCache(\n                this,\n                xpaths,\n                cachePrompt,\n                param.cacheable,\n              );\n          const cacheHitFlag = !!elementFromCache;\n\n          // try matching plan\n          const elementFromPlan =\n            !userExpectedPathHitFlag && !cacheHitFlag\n              ? matchElementFromPlan(param, uiContext.tree)\n              : undefined;\n          const planHitFlag = !!elementFromPlan;\n\n          // try ai locate\n          const elementFromAiLocate =\n            !userExpectedPathHitFlag && !cacheHitFlag && !planHitFlag\n              ? (\n                  await this.insight.locate(param, {\n                    // fallback to ai locate\n                    context: uiContext,\n                  })\n                ).element\n              : undefined;\n          const aiLocateHitFlag = !!elementFromAiLocate;\n\n          const element =\n            elementFromXpath || // highest priority\n            elementFromCache || // second priority\n            elementFromPlan || // third priority\n            elementFromAiLocate;\n\n          // update cache\n          let currentXpaths: string[] | undefined;\n          if (\n            element &&\n            this.taskCache &&\n            !cacheHitFlag &&\n            param?.cacheable !== false\n          ) {\n            const elementXpaths = await this.getElementXpath(\n              uiContext,\n              element,\n            );\n            if (elementXpaths?.length) {\n              currentXpaths = elementXpaths;\n              this.taskCache.updateOrAppendCacheRecord(\n                {\n                  type: 'locate',\n                  prompt: cachePrompt,\n                  xpaths: elementXpaths,\n                },\n                locateCacheRecord,\n              );\n            } else {\n              debug(\n                'no xpaths found, will not update cache',\n                cachePrompt,\n                elementXpaths,\n              );\n            }\n          }\n          if (!element) {\n            throw new Error(`Element not found: ${param.prompt}`);\n          }\n\n          let hitBy: ExecutionTaskHitBy | undefined;\n\n          if (userExpectedPathHitFlag) {\n            hitBy = {\n              from: 'User expected path',\n              context: {\n                xpath: param.xpath,\n              },\n            };\n          } else if (cacheHitFlag) {\n            hitBy = {\n              from: 'Cache',\n              context: {\n                xpathsFromCache: xpaths,\n                xpathsToSave: currentXpaths,\n              },\n            };\n          } else if (planHitFlag) {\n            hitBy = {\n              from: 'Planning',\n              context: {\n                id: elementFromPlan?.id,\n                bbox: elementFromPlan?.bbox,\n              },\n            };\n          } else if (aiLocateHitFlag) {\n            hitBy = {\n              from: 'AI model',\n              context: {\n                prompt: param.prompt,\n              },\n            };\n          }\n\n          onResult?.(element);\n\n          return {\n            output: {\n              element,\n            },\n            uiContext,\n            hitBy,\n          };\n        },\n      };\n      return taskFind;\n    };\n\n    for (const plan of plans) {\n      if (plan.type === 'Locate') {\n        if (\n          !plan.locate ||\n          plan.locate === null ||\n          plan.locate?.id === null ||\n          plan.locate?.id === 'null'\n        ) {\n          debug('Locate action with id is null, will be ignored', plan);\n          continue;\n        }\n        const taskLocate = taskForLocatePlan(plan, plan.locate);\n\n        tasks.push(taskLocate);\n      } else if (plan.type === 'Error') {\n        const taskActionError: ExecutionTaskActionApply<PlanningActionParamError> =\n          {\n            type: 'Action',\n            subType: 'Error',\n            param: plan.param,\n            thought: plan.thought || plan.param?.thought,\n            locate: plan.locate,\n            executor: async () => {\n              throw new Error(\n                plan?.thought || plan.param?.thought || 'error without thought',\n              );\n            },\n          };\n        tasks.push(taskActionError);\n      } else if (plan.type === 'Finished') {\n        const taskActionFinished: ExecutionTaskActionApply<null> = {\n          type: 'Action',\n          subType: 'Finished',\n          param: null,\n          thought: plan.thought,\n          locate: plan.locate,\n          executor: async (param) => {},\n        };\n        tasks.push(taskActionFinished);\n      } else if (plan.type === 'Sleep') {\n        const taskActionSleep: ExecutionTaskActionApply<PlanningActionParamSleep> =\n          {\n            type: 'Action',\n            subType: 'Sleep',\n            param: plan.param,\n            thought: plan.thought,\n            locate: plan.locate,\n            executor: async (taskParam) => {\n              await sleep(taskParam?.timeMs || 3000);\n            },\n          };\n        tasks.push(taskActionSleep);\n      } else {\n        // action in action space\n        const planType = plan.type;\n        const actionSpace = await this.interface.actionSpace();\n        const action = actionSpace.find((action) => action.name === planType);\n        const param = plan.param;\n\n        if (!action) {\n          throw new Error(`Action type '${planType}' not found`);\n        }\n\n        // find all params that needs location\n        const locateFields = action\n          ? findAllMidsceneLocatorField(action.paramSchema)\n          : [];\n\n        const requiredLocateFields = action\n          ? findAllMidsceneLocatorField(action.paramSchema, true)\n          : [];\n\n        locateFields.forEach((field) => {\n          if (param[field]) {\n            const locatePlan = locatePlanForLocate(param[field]);\n            debug(\n              'will prepend locate param for field',\n              `action.type=${planType}`,\n              `param=${JSON.stringify(param[field])}`,\n              `locatePlan=${JSON.stringify(locatePlan)}`,\n            );\n            const locateTask = taskForLocatePlan(\n              locatePlan,\n              param[field],\n              (result) => {\n                param[field] = result;\n              },\n            );\n            tasks.push(locateTask);\n          } else {\n            assert(\n              !requiredLocateFields.includes(field),\n              `Required locate field '${field}' is not provided for action ${planType}`,\n            );\n            debug(`field '${field}' is not provided for action ${planType}`);\n          }\n        });\n\n        const task: ExecutionTaskApply<\n          'Action',\n          any,\n          { success: boolean; action: string; param: any },\n          void\n        > = {\n          type: 'Action',\n          subType: planType,\n          thought: plan.thought,\n          param: plan.param,\n          executor: async (param, context) => {\n            debug(\n              'executing action',\n              planType,\n              param,\n              `context.element.center: ${context.element?.center}`,\n            );\n\n            // Get context for actionSpace operations to ensure size info is available\n            const uiContext = await this.insight.contextRetrieverFn('locate');\n            context.task.uiContext = uiContext;\n\n            requiredLocateFields.forEach((field) => {\n              assert(\n                param[field],\n                `field '${field}' is required for action ${planType} but not provided. Cannot execute action ${planType}.`,\n              );\n            });\n\n            const actionFn = action.call.bind(this.interface);\n            await actionFn(param, context);\n            // Return a proper result for report generation\n            return {\n              output: {\n                success: true,\n                action: planType,\n                param: param,\n              },\n            };\n          },\n        };\n        tasks.push(task);\n      }\n    }\n\n    const wrappedTasks = tasks.map(\n      (task: ExecutionTaskApply, index: number) => {\n        if (task.type === 'Action') {\n          return this.prependExecutorWithScreenshot(\n            task,\n            index === tasks.length - 1,\n          );\n        }\n        return task;\n      },\n    );\n\n    return {\n      tasks: wrappedTasks,\n    };\n  }\n\n  private async setupPlanningContext(executorContext: ExecutorContext) {\n    const shotTime = Date.now();\n    const uiContext = await this.insight.contextRetrieverFn('locate');\n    const recordItem: ExecutionRecorderItem = {\n      type: 'screenshot',\n      ts: shotTime,\n      screenshot: uiContext.screenshotBase64,\n      timing: 'before Planning',\n    };\n\n    executorContext.task.recorder = [recordItem];\n    (executorContext.task as ExecutionTaskPlanning).uiContext = uiContext;\n\n    return {\n      uiContext,\n    };\n  }\n\n  async loadYamlFlowAsPlanning(userInstruction: string, yamlString: string) {\n    const taskExecutor = new Executor(taskTitleStr('Action', userInstruction), {\n      onTaskStart: this.onTaskStartCallback,\n    });\n\n    const task: ExecutionTaskPlanningApply = {\n      type: 'Planning',\n      subType: 'LoadYaml',\n      locate: null,\n      param: {\n        userInstruction,\n      },\n      executor: async (param, executorContext) => {\n        await this.setupPlanningContext(executorContext);\n        return {\n          output: {\n            actions: [],\n            more_actions_needed_by_instruction: false,\n            log: '',\n            yamlString,\n          },\n          cache: {\n            hit: true,\n          },\n          hitBy: {\n            from: 'Cache',\n            context: {\n              yamlString,\n            },\n          },\n        };\n      },\n    };\n\n    await taskExecutor.append(task);\n    await taskExecutor.flush();\n\n    return {\n      executor: taskExecutor,\n    };\n  }\n\n  private planningTaskFromPrompt(\n    userInstruction: string,\n    log?: string,\n    actionContext?: string,\n  ) {\n    const task: ExecutionTaskPlanningApply = {\n      type: 'Planning',\n      subType: 'Plan',\n      locate: null,\n      param: {\n        userInstruction,\n        log,\n      },\n      executor: async (param, executorContext) => {\n        const startTime = Date.now();\n        const { uiContext } = await this.setupPlanningContext(executorContext);\n\n        assert(\n          this.interface.actionSpace,\n          'actionSpace for device is not implemented',\n        );\n        const actionSpace = await this.interface.actionSpace();\n        debug(\n          'actionSpace for this interface is:',\n          actionSpace.map((action) => action.name).join(', '),\n        );\n        assert(Array.isArray(actionSpace), 'actionSpace must be an array');\n        if (actionSpace.length === 0) {\n          console.warn(\n            `ActionSpace for ${this.interface.interfaceType} is empty. This may lead to unexpected behavior.`,\n          );\n        }\n\n        const planResult = await plan(param.userInstruction, {\n          context: uiContext,\n          log: param.log,\n          actionContext,\n          interfaceType: this.interface.interfaceType as InterfaceType,\n          actionSpace,\n        });\n\n        const {\n          actions,\n          log,\n          more_actions_needed_by_instruction,\n          error,\n          usage,\n          rawResponse,\n          sleep,\n        } = planResult;\n\n        executorContext.task.log = {\n          ...(executorContext.task.log || {}),\n          rawResponse,\n        };\n        executorContext.task.usage = usage;\n\n        const finalActions = actions || [];\n\n        // TODO: check locate result\n        // let bboxCollected = false;\n        // (actions || []).reduce<PlanningAction[]>(\n        //   (acc, planningAction) => {\n        //     // TODO: magic field \"locate\" is used to indicate the action requires a locate\n        //     if (planningAction.locate) {\n        //       // we only collect bbox once, let qwen re-locate in the following steps\n        //       if (bboxCollected && planningAction.locate.bbox) {\n        //         // biome-ignore lint/performance/noDelete: <explanation>\n        //         delete planningAction.locate.bbox;\n        //       }\n\n        //       if (planningAction.locate.bbox) {\n        //         bboxCollected = true;\n        //       }\n\n        //       acc.push({\n        //         type: 'Locate',\n        //         locate: planningAction.locate,\n        //         param: null,\n        //         // thought is prompt created by ai, always a string\n        //         thought: planningAction.locate.prompt as string,\n        //       });\n        //     }\n        //     acc.push(planningAction);\n        //     return acc;\n        //   },\n        //   [],\n        // );\n\n        if (sleep) {\n          const timeNow = Date.now();\n          const timeRemaining = sleep - (timeNow - startTime);\n          if (timeRemaining > 0) {\n            finalActions.push({\n              type: 'Sleep',\n              param: {\n                timeMs: timeRemaining,\n              },\n              locate: null,\n            } as PlanningAction<PlanningActionParamSleep>);\n          }\n        }\n\n        if (finalActions.length === 0) {\n          assert(\n            !more_actions_needed_by_instruction || sleep,\n            error ? `Failed to plan: ${error}` : 'No plan found',\n          );\n        }\n\n        return {\n          output: {\n            actions: finalActions,\n            more_actions_needed_by_instruction,\n            log,\n            yamlFlow: planResult.yamlFlow,\n          },\n          cache: {\n            hit: false,\n          },\n          uiContext,\n        };\n      },\n    };\n\n    return task;\n  }\n\n  private planningTaskToGoal(\n    userInstruction: string,\n    modelPreferences: IModelPreferences,\n  ) {\n    const task: ExecutionTaskPlanningApply = {\n      type: 'Planning',\n      subType: 'Plan',\n      locate: null,\n      param: {\n        userInstruction,\n      },\n      executor: async (param, executorContext) => {\n        const { uiContext } = await this.setupPlanningContext(executorContext);\n\n        const imagePayload = await resizeImageForUiTars(\n          uiContext.screenshotBase64,\n          uiContext.size,\n          modelPreferences,\n        );\n\n        this.appendConversationHistory({\n          role: 'user',\n          content: [\n            {\n              type: 'image_url',\n              image_url: {\n                url: imagePayload,\n              },\n            },\n          ],\n        });\n        const planResult: {\n          actions: PlanningAction<any>[];\n          action_summary: string;\n          usage?: AIUsageInfo;\n          yamlFlow?: MidsceneYamlFlowItem[];\n          rawResponse?: string;\n        } = await vlmPlanning({\n          userInstruction: param.userInstruction,\n          conversationHistory: this.conversationHistory,\n          size: uiContext.size,\n          modelPreferences,\n        });\n\n        const { actions, action_summary, usage } = planResult;\n        executorContext.task.log = {\n          ...(executorContext.task.log || {}),\n          rawResponse: planResult.rawResponse,\n        };\n        executorContext.task.usage = usage;\n        this.appendConversationHistory({\n          role: 'assistant',\n          content: action_summary,\n        });\n        return {\n          output: {\n            actions,\n            thought: actions[0]?.thought,\n            actionType: actions[0].type,\n            more_actions_needed_by_instruction: true,\n            log: '',\n            yamlFlow: planResult.yamlFlow,\n          },\n          cache: {\n            hit: false,\n          },\n        };\n      },\n    };\n\n    return task;\n  }\n\n  async runPlans(\n    title: string,\n    plans: PlanningAction[],\n  ): Promise<ExecutionResult> {\n    const taskExecutor = new Executor(title, {\n      onTaskStart: this.onTaskStartCallback,\n    });\n    const { tasks } = await this.convertPlanToExecutable(plans);\n    await taskExecutor.append(tasks);\n    const result = await taskExecutor.flush();\n    const { output } = result!;\n    return {\n      output,\n      executor: taskExecutor,\n    };\n  }\n\n  async action(\n    userPrompt: string,\n    actionContext?: string,\n  ): Promise<\n    ExecutionResult<\n      | {\n          yamlFlow?: MidsceneYamlFlowItem[]; // for cache use\n        }\n      | undefined\n    >\n  > {\n    const taskExecutor = new Executor(taskTitleStr('Action', userPrompt), {\n      onTaskStart: this.onTaskStartCallback,\n    });\n\n    let planningTask: ExecutionTaskPlanningApply | null =\n      this.planningTaskFromPrompt(userPrompt, undefined, actionContext);\n    let replanCount = 0;\n    const logList: string[] = [];\n\n    const yamlFlow: MidsceneYamlFlowItem[] = [];\n    const replanningCycleLimit =\n      globalConfigManager.getEnvConfigInNumber(\n        MIDSCENE_REPLANNING_CYCLE_LIMIT,\n      ) || defaultReplanningCycleLimit;\n    while (planningTask) {\n      if (replanCount > replanningCycleLimit) {\n        const errorMsg =\n          'Replanning too many times, please split the task into multiple steps';\n\n        return this.appendErrorPlan(taskExecutor, errorMsg);\n      }\n\n      // plan\n      await taskExecutor.append(planningTask);\n      const result = await taskExecutor.flush();\n      const planResult: PlanningAIResponse = result?.output;\n      if (taskExecutor.isInErrorState()) {\n        return {\n          output: planResult,\n          executor: taskExecutor,\n        };\n      }\n\n      const plans = planResult.actions || [];\n      yamlFlow.push(...(planResult.yamlFlow || []));\n\n      let executables: Awaited<ReturnType<typeof this.convertPlanToExecutable>>;\n      try {\n        executables = await this.convertPlanToExecutable(plans);\n        taskExecutor.append(executables.tasks);\n      } catch (error) {\n        return this.appendErrorPlan(\n          taskExecutor,\n          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(\n            plans,\n          )}`,\n        );\n      }\n\n      await taskExecutor.flush();\n      if (taskExecutor.isInErrorState()) {\n        return {\n          output: undefined,\n          executor: taskExecutor,\n        };\n      }\n      if (planResult?.log) {\n        logList.push(planResult.log);\n      }\n\n      if (!planResult.more_actions_needed_by_instruction) {\n        planningTask = null;\n        break;\n      }\n      planningTask = this.planningTaskFromPrompt(\n        userPrompt,\n        logList.length > 0 ? `- ${logList.join('\\n- ')}` : undefined,\n        actionContext,\n      );\n      replanCount++;\n    }\n\n    return {\n      output: {\n        yamlFlow,\n      },\n      executor: taskExecutor,\n    };\n  }\n\n  async actionToGoal(userPrompt: string): Promise<\n    ExecutionResult<\n      | {\n          yamlFlow?: MidsceneYamlFlowItem[]; // for cache use\n        }\n      | undefined\n    >\n  > {\n    const taskExecutor = new Executor(taskTitleStr('Action', userPrompt), {\n      onTaskStart: this.onTaskStartCallback,\n    });\n    this.conversationHistory = [];\n    const isCompleted = false;\n    let currentActionCount = 0;\n    const maxActionNumber = 40;\n\n    const yamlFlow: MidsceneYamlFlowItem[] = [];\n    while (!isCompleted && currentActionCount < maxActionNumber) {\n      currentActionCount++;\n      debug(\n        'actionToGoal, currentActionCount:',\n        currentActionCount,\n        'userPrompt:',\n        userPrompt,\n      );\n      const planningTask: ExecutionTaskPlanningApply = this.planningTaskToGoal(\n        userPrompt,\n        {\n          intent: 'planning',\n        },\n      );\n      await taskExecutor.append(planningTask);\n      const result = await taskExecutor.flush();\n      if (taskExecutor.isInErrorState()) {\n        return {\n          output: undefined,\n          executor: taskExecutor,\n        };\n      }\n      if (!result) {\n        throw new Error(\n          'result of taskExecutor.flush() is undefined in function actionToGoal',\n        );\n      }\n      const { output } = result;\n      const plans = output.actions;\n      yamlFlow.push(...(output.yamlFlow || []));\n      let executables: Awaited<ReturnType<typeof this.convertPlanToExecutable>>;\n      try {\n        executables = await this.convertPlanToExecutable(plans);\n        taskExecutor.append(executables.tasks);\n      } catch (error) {\n        return this.appendErrorPlan(\n          taskExecutor,\n          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(\n            plans,\n          )}`,\n        );\n      }\n\n      await taskExecutor.flush();\n\n      if (taskExecutor.isInErrorState()) {\n        return {\n          output: undefined,\n          executor: taskExecutor,\n        };\n      }\n\n      if (plans[0].type === 'Finished') {\n        break;\n      }\n    }\n    return {\n      output: {\n        yamlFlow,\n      },\n      executor: taskExecutor,\n    };\n  }\n\n  private createTypeQueryTask(\n    type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert',\n    demand: InsightExtractParam,\n    opt?: InsightExtractOption,\n    multimodalPrompt?: TMultimodalPrompt,\n  ) {\n    const queryTask: ExecutionTaskInsightQueryApply = {\n      type: 'Insight',\n      subType: type,\n      locate: null,\n      param: {\n        // TODO: display image thumbnail in report\n        dataDemand: multimodalPrompt\n          ? ({\n              demand,\n              multimodalPrompt,\n            } as never)\n          : demand, // for user param presentation in report right sidebar\n      },\n      executor: async (param, taskContext) => {\n        const { task } = taskContext;\n        let insightDump: InsightDump | undefined;\n        const dumpCollector: DumpSubscriber = (dump) => {\n          insightDump = dump;\n        };\n        this.insight.onceDumpUpdatedFn = dumpCollector;\n\n        // Get context for query operations\n        const shotTime = Date.now();\n        const uiContext = await this.insight.contextRetrieverFn('extract');\n        task.uiContext = uiContext;\n\n        const recordItem: ExecutionRecorderItem = {\n          type: 'screenshot',\n          ts: shotTime,\n          screenshot: uiContext.screenshotBase64,\n          timing: 'before Extract',\n        };\n        task.recorder = [recordItem];\n\n        const ifTypeRestricted = type !== 'Query';\n        let demandInput = demand;\n        if (ifTypeRestricted) {\n          const returnType = type === 'Assert' ? 'Boolean' : type;\n          demandInput = {\n            result: `${returnType}, ${demand}`,\n          };\n        }\n\n        const { data, usage, thought } = await this.insight.extract<any>(\n          demandInput,\n          opt,\n          multimodalPrompt,\n        );\n\n        let outputResult = data;\n        if (ifTypeRestricted) {\n          // If AI returned a plain string instead of structured format, use it directly\n          if (typeof data === 'string') {\n            outputResult = data;\n          } else {\n            assert(data?.result !== undefined, 'No result in query data');\n            outputResult = (data as any).result;\n          }\n        }\n\n        return {\n          output: outputResult,\n          log: { dump: insightDump, isWaitForAssert: opt?.isWaitForAssert },\n          usage,\n          thought,\n        };\n      },\n    };\n\n    return queryTask;\n  }\n  async createTypeQueryExecution<T>(\n    type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert',\n    demand: InsightExtractParam,\n    opt?: InsightExtractOption,\n    multimodalPrompt?: TMultimodalPrompt,\n  ): Promise<ExecutionResult<T>> {\n    const taskExecutor = new Executor(\n      taskTitleStr(\n        type,\n        typeof demand === 'string' ? demand : JSON.stringify(demand),\n      ),\n      {\n        onTaskStart: this.onTaskStartCallback,\n      },\n    );\n\n    const queryTask = await this.createTypeQueryTask(\n      type,\n      demand,\n      opt,\n      multimodalPrompt,\n    );\n\n    await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));\n    const result = await taskExecutor.flush();\n\n    if (!result) {\n      throw new Error(\n        'result of taskExecutor.flush() is undefined in function createTypeQueryTask',\n      );\n    }\n\n    const { output, thought } = result;\n\n    return {\n      output,\n      thought,\n      executor: taskExecutor,\n    };\n  }\n\n  async assert(\n    assertion: TUserPrompt,\n    opt?: InsightExtractOption,\n  ): Promise<ExecutionResult<boolean>> {\n    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);\n    return await this.createTypeQueryExecution<boolean>(\n      'Assert',\n      textPrompt,\n      opt,\n      multimodalPrompt,\n    );\n  }\n\n  /**\n   * Append a message to the conversation history\n   * For user messages with images:\n   * - Keep max 4 user image messages in history\n   * - Remove oldest user image message when limit reached\n   * For assistant messages:\n   * - Simply append to history\n   * @param conversationHistory Message to append\n   */\n  private appendConversationHistory(\n    conversationHistory: ChatCompletionMessageParam,\n  ) {\n    if (conversationHistory.role === 'user') {\n      // Get all existing user messages with images\n      const userImgItems = this.conversationHistory.filter(\n        (item) => item.role === 'user',\n      );\n\n      // If we already have 4 user image messages\n      if (userImgItems.length >= 4 && conversationHistory.role === 'user') {\n        // Remove first user image message when we already have 4, before adding new one\n        const firstUserImgIndex = this.conversationHistory.findIndex(\n          (item) => item.role === 'user',\n        );\n        if (firstUserImgIndex >= 0) {\n          this.conversationHistory.splice(firstUserImgIndex, 1);\n        }\n      }\n    }\n    // For non-user messages, simply append to history\n    this.conversationHistory.push(conversationHistory);\n  }\n\n  private async appendErrorPlan(taskExecutor: Executor, errorMsg: string) {\n    const errorPlan: PlanningAction<PlanningActionParamError> = {\n      type: 'Error',\n      param: {\n        thought: errorMsg,\n      },\n      locate: null,\n    };\n    const { tasks } = await this.convertPlanToExecutable([errorPlan]);\n    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));\n    await taskExecutor.flush();\n\n    return {\n      output: undefined,\n      executor: taskExecutor,\n    };\n  }\n\n  async waitFor(\n    assertion: TUserPrompt,\n    opt: PlanningActionParamWaitFor,\n  ): Promise<ExecutionResult<void>> {\n    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);\n\n    const description = `waitFor: ${textPrompt}`;\n    const taskExecutor = new Executor(taskTitleStr('WaitFor', description), {\n      onTaskStart: this.onTaskStartCallback,\n    });\n    const { timeoutMs, checkIntervalMs } = opt;\n\n    assert(assertion, 'No assertion for waitFor');\n    assert(timeoutMs, 'No timeoutMs for waitFor');\n    assert(checkIntervalMs, 'No checkIntervalMs for waitFor');\n\n    assert(\n      checkIntervalMs <= timeoutMs,\n      `wrong config for waitFor: checkIntervalMs must be less than timeoutMs, config: {checkIntervalMs: ${checkIntervalMs}, timeoutMs: ${timeoutMs}}`,\n    );\n\n    const overallStartTime = Date.now();\n    let startTime = Date.now();\n    let errorThought = '';\n    while (Date.now() - overallStartTime < timeoutMs) {\n      startTime = Date.now();\n      const queryTask = await this.createTypeQueryTask(\n        'Assert',\n        textPrompt,\n        {\n          isWaitForAssert: true,\n          returnThought: true,\n          doNotThrowError: true,\n        },\n        multimodalPrompt,\n      );\n\n      await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));\n      const result = (await taskExecutor.flush()) as {\n        output: boolean;\n        thought?: string;\n      };\n\n      if (!result) {\n        throw new Error(\n          'result of taskExecutor.flush() is undefined in function waitFor',\n        );\n      }\n\n      if (result?.output) {\n        return {\n          output: undefined,\n          executor: taskExecutor,\n        };\n      }\n\n      errorThought =\n        result?.thought ||\n        `unknown error when waiting for assertion: ${textPrompt}`;\n      const now = Date.now();\n      if (now - startTime < checkIntervalMs) {\n        const timeRemaining = checkIntervalMs - (now - startTime);\n        const sleepPlan: PlanningAction<PlanningActionParamSleep> = {\n          type: 'Sleep',\n          param: {\n            timeMs: timeRemaining,\n          },\n          locate: null,\n        };\n        const { tasks: sleepTasks } = await this.convertPlanToExecutable([\n          sleepPlan,\n        ]);\n        await taskExecutor.append(\n          this.prependExecutorWithScreenshot(sleepTasks[0]),\n        );\n        await taskExecutor.flush();\n      }\n    }\n\n    return this.appendErrorPlan(\n      taskExecutor,\n      `waitFor timeout: ${errorThought}`,\n    );\n  }\n}\n"],"names":["debug","getDebug","defaultReplanningCycleLimit","locatePlanForLocate","param","locate","locatePlan","TaskExecutor","timing","base64","item","Date","uiContext","element","_element_attributes","elementId","undefined","xpaths","NodeType","info","elementByPositionWithElementInfo","result","error","taskApply","appendAfterExecution","taskWithScreenshot","context","args","recorder","task","shot","Promise","sleep","shot2","plans","tasks","taskForLocatePlan","plan","detailedLocateParam","onResult","taskFind","taskContext","_this_taskCache","_locateCacheRecord_cacheContent","assert","JSON","insightDump","usage","dumpCollector","dump","_dump_taskInfo","shotTime","recordItem","elementFromXpath","userExpectedPathHitFlag","cachePrompt","locateCacheRecord","elementFromCache","matchElementFromCache","cacheHitFlag","elementFromPlan","matchElementFromPlan","planHitFlag","elementFromAiLocate","aiLocateHitFlag","currentXpaths","elementXpaths","Error","hitBy","_plan_locate","_plan_locate1","taskLocate","_plan_param","taskActionError","taskActionFinished","taskActionSleep","taskParam","planType","actionSpace","action","locateFields","findAllMidsceneLocatorField","requiredLocateFields","field","locateTask","_context_element","actionFn","wrappedTasks","index","executorContext","userInstruction","yamlString","taskExecutor","Executor","taskTitleStr","log","actionContext","startTime","Array","console","planResult","actions","more_actions_needed_by_instruction","rawResponse","finalActions","timeNow","timeRemaining","modelPreferences","_actions_","imagePayload","resizeImageForUiTars","vlmPlanning","action_summary","title","output","userPrompt","planningTask","replanCount","logList","yamlFlow","replanningCycleLimit","globalConfigManager","MIDSCENE_REPLANNING_CYCLE_LIMIT","errorMsg","executables","isCompleted","currentActionCount","maxActionNumber","type","demand","opt","multimodalPrompt","queryTask","ifTypeRestricted","demandInput","returnType","data","thought","outputResult","assertion","textPrompt","parsePrompt","conversationHistory","userImgItems","firstUserImgIndex","errorPlan","description","timeoutMs","checkIntervalMs","overallStartTime","errorThought","now","sleepPlan","sleepTasks","interfaceInstance","insight","opts"],"mappings":"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"}