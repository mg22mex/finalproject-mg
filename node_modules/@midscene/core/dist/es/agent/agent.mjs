import { Insight } from "../index.mjs";
import js_yaml from "js-yaml";
import { groupedActionDumpFileExt, reportHTMLContent, stringifyDumpData, writeLogFile } from "../utils.mjs";
import { ScriptPlayer, buildDetailedLocateParam, parseYamlScript } from "../yaml/index.mjs";
import { MIDSCENE_CACHE, globalConfigManager, vlLocateMode } from "@midscene/shared/env";
import { getDebug } from "@midscene/shared/logger";
import { assert } from "@midscene/shared/utils";
import { TaskCache } from "./task-cache.mjs";
import { TaskExecutor, locatePlanForLocate } from "./tasks.mjs";
import { locateParamStr, paramStr, taskTitleStr, typeStr } from "./ui-utils.mjs";
import { commonContextParser, getReportFileName, parsePrompt, printReportMsg, trimContextByViewport } from "./utils.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const debug = getDebug('agent');
const distanceOfTwoPoints = (p1, p2)=>{
    const [x1, y1] = p1;
    const [x2, y2] = p2;
    return Math.round(Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2));
};
const includedInRect = (point, rect)=>{
    const [x, y] = point;
    const { left, top, width, height } = rect;
    return x >= left && x <= left + width && y >= top && y <= top + height;
};
const defaultInsightExtractOption = {
    domIncluded: false,
    screenshotIncluded: true
};
class Agent {
    get page() {
        return this.interface;
    }
    async getActionSpace() {
        return this.interface.actionSpace();
    }
    async getUIContext(action) {
        if (this.frozenUIContext) {
            debug('Using frozen page context for action:', action);
            return this.frozenUIContext;
        }
        if (this.interface.getContext) {
            debug('Using page.getContext for action:', action);
            return await this.interface.getContext();
        }
        debug('Using commonContextParser for action:', action);
        return await commonContextParser(this.interface);
    }
    async _snapshotContext() {
        return await this.getUIContext('locate');
    }
    async setAIActionContext(prompt) {
        this.opts.aiActionContext = prompt;
    }
    resetDump() {
        this.dump = {
            groupName: this.opts.groupName,
            groupDescription: this.opts.groupDescription,
            executions: [],
            modelBriefs: []
        };
        return this.dump;
    }
    appendExecutionDump(execution) {
        const trimmedExecution = trimContextByViewport(execution);
        const currentDump = this.dump;
        currentDump.executions.push(trimmedExecution);
    }
    dumpDataString() {
        this.dump.groupName = this.opts.groupName;
        this.dump.groupDescription = this.opts.groupDescription;
        return stringifyDumpData(this.dump);
    }
    reportHTMLString() {
        return reportHTMLContent(this.dumpDataString());
    }
    writeOutActionDumps() {
        if (this.destroyed) throw new Error('PageAgent has been destroyed. Cannot update report file.');
        const { generateReport, autoPrintReportMsg } = this.opts;
        this.reportFile = writeLogFile({
            fileName: this.reportFileName,
            fileExt: groupedActionDumpFileExt,
            fileContent: this.dumpDataString(),
            type: 'dump',
            generateReport
        });
        debug('writeOutActionDumps', this.reportFile);
        if (generateReport && autoPrintReportMsg && this.reportFile) printReportMsg(this.reportFile);
    }
    async callbackOnTaskStartTip(task) {
        const param = paramStr(task);
        const tip = param ? `${typeStr(task)} - ${param}` : typeStr(task);
        if (this.onTaskStartTip) await this.onTaskStartTip(tip);
    }
    async afterTaskRunning(executor, doNotThrowError = false) {
        this.appendExecutionDump(executor.dump());
        try {
            if (this.onDumpUpdate) this.onDumpUpdate(this.dumpDataString());
        } catch (error) {
            console.error('Error in onDumpUpdate', error);
        }
        this.writeOutActionDumps();
        if (executor.isInErrorState() && !doNotThrowError) {
            const errorTask = executor.latestErrorTask();
            throw new Error(`${null == errorTask ? void 0 : errorTask.errorMessage}\n${null == errorTask ? void 0 : errorTask.errorStack}`, {
                cause: null == errorTask ? void 0 : errorTask.error
            });
        }
    }
    async callActionInActionSpace(type, opt) {
        debug('callActionInActionSpace', type, ',', opt, ',', opt);
        const actionPlan = {
            type: type,
            param: opt || {},
            thought: ''
        };
        debug('actionPlan', actionPlan);
        const plans = [
            actionPlan
        ].filter(Boolean);
        const title = taskTitleStr(type, locateParamStr((null == opt ? void 0 : opt.locate) || {}));
        const { output, executor } = await this.taskExecutor.runPlans(title, plans);
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiTap(locatePrompt, opt) {
        assert(locatePrompt, 'missing locate prompt for tap');
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
        return this.callActionInActionSpace('Tap', {
            locate: detailedLocateParam
        });
    }
    async aiRightClick(locatePrompt, opt) {
        assert(locatePrompt, 'missing locate prompt for right click');
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
        return this.callActionInActionSpace('RightClick', {
            locate: detailedLocateParam
        });
    }
    async aiHover(locatePrompt, opt) {
        assert(locatePrompt, 'missing locate prompt for hover');
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
        return this.callActionInActionSpace('Hover', {
            locate: detailedLocateParam
        });
    }
    async aiInput(locatePromptOrValue, locatePromptOrOpt, optOrUndefined) {
        let value;
        let locatePrompt;
        let opt;
        if ('object' == typeof locatePromptOrOpt && null !== locatePromptOrOpt && 'value' in locatePromptOrOpt) {
            locatePrompt = locatePromptOrValue;
            const optWithValue = locatePromptOrOpt;
            value = optWithValue.value;
            opt = optWithValue;
        } else {
            value = locatePromptOrValue;
            locatePrompt = locatePromptOrOpt;
            opt = {
                ...optOrUndefined,
                value
            };
        }
        assert('string' == typeof value, 'input value must be a string, use empty string if you want to clear the input');
        assert(locatePrompt, 'missing locate prompt for input');
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
        return this.callActionInActionSpace('Input', {
            ...opt || {},
            locate: detailedLocateParam
        });
    }
    async aiKeyboardPress(locatePromptOrKeyName, locatePromptOrOpt, optOrUndefined) {
        let keyName;
        let locatePrompt;
        let opt;
        if ('object' == typeof locatePromptOrOpt && null !== locatePromptOrOpt && 'keyName' in locatePromptOrOpt) {
            locatePrompt = locatePromptOrKeyName;
            opt = locatePromptOrOpt;
        } else {
            keyName = locatePromptOrKeyName;
            locatePrompt = locatePromptOrOpt;
            opt = {
                ...optOrUndefined || {},
                keyName
            };
        }
        assert(null == opt ? void 0 : opt.keyName, 'missing keyName for keyboard press');
        const detailedLocateParam = locatePrompt ? buildDetailedLocateParam(locatePrompt, opt) : void 0;
        return this.callActionInActionSpace('KeyboardPress', {
            ...opt || {},
            locate: detailedLocateParam
        });
    }
    async aiScroll(locatePromptOrScrollParam, locatePromptOrOpt, optOrUndefined) {
        let scrollParam;
        let locatePrompt;
        let opt;
        if ('object' == typeof locatePromptOrOpt && ('direction' in locatePromptOrOpt || 'scrollType' in locatePromptOrOpt || 'distance' in locatePromptOrOpt)) {
            locatePrompt = locatePromptOrScrollParam;
            opt = locatePromptOrOpt;
        } else {
            scrollParam = locatePromptOrScrollParam;
            locatePrompt = locatePromptOrOpt;
            opt = {
                ...optOrUndefined || {},
                ...scrollParam || {}
            };
        }
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt || '', opt);
        return this.callActionInActionSpace('Scroll', {
            ...opt || {},
            locate: detailedLocateParam
        });
    }
    async aiAction(taskPrompt, opt) {
        var _this_taskCache, _this_taskCache1;
        const modelPreferences = {
            intent: 'planning'
        };
        const cacheable = null == opt ? void 0 : opt.cacheable;
        const isVlmUiTars = 'vlm-ui-tars' === vlLocateMode(modelPreferences);
        const matchedCache = isVlmUiTars || false === cacheable ? void 0 : null == (_this_taskCache = this.taskCache) ? void 0 : _this_taskCache.matchPlanCache(taskPrompt);
        if (matchedCache && (null == (_this_taskCache1 = this.taskCache) ? void 0 : _this_taskCache1.isCacheResultUsed)) {
            var _matchedCache_cacheContent, _matchedCache_cacheContent1;
            const { executor } = await this.taskExecutor.loadYamlFlowAsPlanning(taskPrompt, null == (_matchedCache_cacheContent = matchedCache.cacheContent) ? void 0 : _matchedCache_cacheContent.yamlWorkflow);
            await this.afterTaskRunning(executor);
            debug('matched cache, will call .runYaml to run the action');
            const yaml = null == (_matchedCache_cacheContent1 = matchedCache.cacheContent) ? void 0 : _matchedCache_cacheContent1.yamlWorkflow;
            return this.runYaml(yaml);
        }
        const { output, executor } = await (isVlmUiTars ? this.taskExecutor.actionToGoal(taskPrompt) : this.taskExecutor.action(taskPrompt, this.opts.aiActionContext));
        if (this.taskCache && (null == output ? void 0 : output.yamlFlow) && false !== cacheable) {
            const yamlContent = {
                tasks: [
                    {
                        name: taskPrompt,
                        flow: output.yamlFlow
                    }
                ]
            };
            const yamlFlowStr = js_yaml.dump(yamlContent);
            this.taskCache.updateOrAppendCacheRecord({
                type: 'plan',
                prompt: taskPrompt,
                yamlWorkflow: yamlFlowStr
            }, matchedCache);
        }
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiQuery(demand, opt = defaultInsightExtractOption) {
        const { output, executor } = await this.taskExecutor.createTypeQueryExecution('Query', demand, opt);
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiBoolean(prompt, opt = defaultInsightExtractOption) {
        const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
        const { output, executor } = await this.taskExecutor.createTypeQueryExecution('Boolean', textPrompt, opt, multimodalPrompt);
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiNumber(prompt, opt = defaultInsightExtractOption) {
        const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
        const { output, executor } = await this.taskExecutor.createTypeQueryExecution('Number', textPrompt, opt, multimodalPrompt);
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiString(prompt, opt = defaultInsightExtractOption) {
        const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
        const { output, executor } = await this.taskExecutor.createTypeQueryExecution('String', textPrompt, opt, multimodalPrompt);
        await this.afterTaskRunning(executor);
        return output;
    }
    async aiAsk(prompt, opt = defaultInsightExtractOption) {
        return this.aiString(prompt, opt);
    }
    async describeElementAtPoint(center, opt) {
        const { verifyPrompt = true, retryLimit = 3 } = opt || {};
        let success = false;
        let retryCount = 0;
        let resultPrompt = '';
        let deepThink = (null == opt ? void 0 : opt.deepThink) || false;
        let verifyResult;
        while(!success && retryCount < retryLimit){
            if (retryCount >= 2) deepThink = true;
            debug('aiDescribe', center, 'verifyPrompt', verifyPrompt, 'retryCount', retryCount, 'deepThink', deepThink);
            const text = await this.insight.describe(center, {
                deepThink
            });
            debug('aiDescribe text', text);
            assert(text.description, `failed to describe element at [${center}]`);
            resultPrompt = text.description;
            verifyResult = await this.verifyLocator(resultPrompt, deepThink ? {
                deepThink: true
            } : void 0, center, opt);
            if (verifyResult.pass) success = true;
            else retryCount++;
        }
        return {
            prompt: resultPrompt,
            deepThink,
            verifyResult
        };
    }
    async verifyLocator(prompt, locateOpt, expectCenter, verifyLocateOption) {
        debug('verifyLocator', prompt, locateOpt, expectCenter, verifyLocateOption);
        const { center: verifyCenter, rect: verifyRect } = await this.aiLocate(prompt, locateOpt);
        const distance = distanceOfTwoPoints(expectCenter, verifyCenter);
        const included = includedInRect(expectCenter, verifyRect);
        const pass = distance <= ((null == verifyLocateOption ? void 0 : verifyLocateOption.centerDistanceThreshold) || 20) || included;
        const verifyResult = {
            pass,
            rect: verifyRect,
            center: verifyCenter,
            centerDistance: distance
        };
        debug('aiDescribe verifyResult', verifyResult);
        return verifyResult;
    }
    async aiLocate(prompt, opt) {
        const locateParam = buildDetailedLocateParam(prompt, opt);
        assert(locateParam, 'cannot get locate param for aiLocate');
        const locatePlan = locatePlanForLocate(locateParam);
        const plans = [
            locatePlan
        ];
        const { executor, output } = await this.taskExecutor.runPlans(taskTitleStr('Locate', locateParamStr(locateParam)), plans);
        await this.afterTaskRunning(executor);
        const { element } = output;
        return {
            rect: null == element ? void 0 : element.rect,
            center: null == element ? void 0 : element.center,
            scale: (await this.interface.size()).dpr
        };
    }
    async aiAssert(assertion, msg, opt) {
        var _executor_latestErrorTask;
        const insightOpt = {
            domIncluded: (null == opt ? void 0 : opt.domIncluded) ?? defaultInsightExtractOption.domIncluded,
            screenshotIncluded: (null == opt ? void 0 : opt.screenshotIncluded) ?? defaultInsightExtractOption.screenshotIncluded,
            returnThought: (null == opt ? void 0 : opt.returnThought) ?? true,
            isWaitForAssert: null == opt ? void 0 : opt.isWaitForAssert,
            doNotThrowError: null == opt ? void 0 : opt.doNotThrowError
        };
        const { output, executor, thought } = await this.taskExecutor.assert(assertion, insightOpt);
        await this.afterTaskRunning(executor, true);
        const message = output ? void 0 : `Assertion failed: ${msg || assertion}\nReason: ${thought || (null == (_executor_latestErrorTask = executor.latestErrorTask()) ? void 0 : _executor_latestErrorTask.error) || '(no_reason)'}`;
        if (null == opt ? void 0 : opt.keepRawResponse) return {
            pass: output,
            thought,
            message
        };
        if (!output) throw new Error(message);
    }
    async aiWaitFor(assertion, opt) {
        const { executor } = await this.taskExecutor.waitFor(assertion, {
            timeoutMs: (null == opt ? void 0 : opt.timeoutMs) || 15000,
            checkIntervalMs: (null == opt ? void 0 : opt.checkIntervalMs) || 3000
        });
        await this.afterTaskRunning(executor, true);
        if (executor.isInErrorState()) {
            const errorTask = executor.latestErrorTask();
            throw new Error(`${null == errorTask ? void 0 : errorTask.error}\n${null == errorTask ? void 0 : errorTask.errorStack}`);
        }
    }
    async ai(taskPrompt, type = 'action') {
        if ('action' === type) return this.aiAction(taskPrompt);
        if ('query' === type) return this.aiQuery(taskPrompt);
        if ('assert' === type) return this.aiAssert(taskPrompt);
        if ('tap' === type) return this.aiTap(taskPrompt);
        if ('rightClick' === type) return this.aiRightClick(taskPrompt);
        throw new Error(`Unknown type: ${type}, only support 'action', 'query', 'assert', 'tap', 'rightClick'`);
    }
    async runYaml(yamlScriptContent) {
        const script = parseYamlScript(yamlScriptContent, 'yaml', true);
        const player = new ScriptPlayer(script, async ()=>({
                agent: this,
                freeFn: []
            }));
        await player.run();
        if ('error' === player.status) {
            const errors = player.taskStatusList.filter((task)=>'error' === task.status).map((task)=>{
                var _task_error;
                return `task - ${task.name}: ${null == (_task_error = task.error) ? void 0 : _task_error.message}`;
            }).join('\n');
            throw new Error(`Error(s) occurred in running yaml script:\n${errors}`);
        }
        return {
            result: player.result
        };
    }
    async evaluateJavaScript(script) {
        assert(this.interface.evaluateJavaScript, 'evaluateJavaScript is not supported in current agent');
        return this.interface.evaluateJavaScript(script);
    }
    async destroy() {
        await this.interface.destroy();
        this.resetDump();
        this.destroyed = true;
    }
    async logScreenshot(title, opt) {
        const base64 = await this.interface.screenshotBase64();
        const now = Date.now();
        const recorder = [
            {
                type: 'screenshot',
                ts: now,
                screenshot: base64
            }
        ];
        const task = {
            type: 'Log',
            subType: 'Screenshot',
            status: 'finished',
            recorder,
            timing: {
                start: now,
                end: now,
                cost: 0
            },
            param: {
                content: (null == opt ? void 0 : opt.content) || ''
            },
            executor: async ()=>{}
        };
        const executionDump = {
            sdkVersion: '',
            logTime: now,
            name: `Log - ${title || 'untitled'}`,
            description: (null == opt ? void 0 : opt.content) || '',
            tasks: [
                task
            ]
        };
        this.appendExecutionDump(executionDump);
        try {
            var _this_onDumpUpdate, _this;
            null == (_this_onDumpUpdate = (_this = this).onDumpUpdate) || _this_onDumpUpdate.call(_this, this.dumpDataString());
        } catch (error) {
            console.error('Failed to update dump', error);
        }
        this.writeOutActionDumps();
    }
    _unstableLogContent() {
        const { groupName, groupDescription, executions } = this.dump;
        const newExecutions = Array.isArray(executions) ? executions.map((execution)=>{
            const { tasks, ...restExecution } = execution;
            let newTasks = tasks;
            if (Array.isArray(tasks)) newTasks = tasks.map((task)=>{
                const { uiContext, log, ...restTask } = task;
                return restTask;
            });
            return {
                ...restExecution,
                ...newTasks ? {
                    tasks: newTasks
                } : {}
            };
        }) : [];
        return {
            groupName,
            groupDescription,
            executions: newExecutions
        };
    }
    async freezePageContext() {
        debug('Freezing page context');
        const context = await this._snapshotContext();
        context._isFrozen = true;
        this.frozenUIContext = context;
        debug('Page context frozen successfully');
    }
    async unfreezePageContext() {
        debug('Unfreezing page context');
        this.frozenUIContext = void 0;
        debug('Page context unfrozen successfully');
    }
    constructor(interfaceInstance, opts){
        _define_property(this, "interface", void 0);
        _define_property(this, "insight", void 0);
        _define_property(this, "dump", void 0);
        _define_property(this, "reportFile", void 0);
        _define_property(this, "reportFileName", void 0);
        _define_property(this, "taskExecutor", void 0);
        _define_property(this, "opts", void 0);
        _define_property(this, "dryMode", false);
        _define_property(this, "onTaskStartTip", void 0);
        _define_property(this, "taskCache", void 0);
        _define_property(this, "onDumpUpdate", void 0);
        _define_property(this, "destroyed", false);
        _define_property(this, "frozenUIContext", void 0);
        this.interface = interfaceInstance;
        this.opts = Object.assign({
            generateReport: true,
            autoPrintReportMsg: true,
            groupName: 'Midscene Report',
            groupDescription: ''
        }, opts || {});
        if ((null == opts ? void 0 : opts.modelConfig) && 'function' != typeof (null == opts ? void 0 : opts.modelConfig)) throw new Error(`opts.modelConfig must be one of function or undefined, but got ${typeof (null == opts ? void 0 : opts.modelConfig)}`);
        globalConfigManager.init(null == opts ? void 0 : opts.modelConfig);
        this.onTaskStartTip = this.opts.onTaskStartTip;
        this.insight = new Insight(async (action)=>this.getUIContext(action));
        if ((null == opts ? void 0 : opts.cacheId) && 'android' !== this.interface.interfaceType) this.taskCache = new TaskCache(opts.cacheId, globalConfigManager.getEnvConfigInBoolean(MIDSCENE_CACHE));
        this.taskExecutor = new TaskExecutor(this.interface, this.insight, {
            taskCache: this.taskCache,
            onTaskStart: this.callbackOnTaskStartTip.bind(this)
        });
        this.dump = this.resetDump();
        this.reportFileName = (null == opts ? void 0 : opts.reportFileName) || getReportFileName((null == opts ? void 0 : opts.testId) || this.interface.interfaceType || 'web');
    }
}
export { Agent };

//# sourceMappingURL=agent.mjs.map