"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    SizeSchema: ()=>SizeSchema,
    TMultimodalPromptSchema: ()=>TMultimodalPromptSchema,
    expandSearchArea: ()=>expandSearchArea,
    AIActionType: ()=>common_AIActionType,
    adaptBbox: ()=>adaptBbox,
    TUserPromptSchema: ()=>TUserPromptSchema,
    findAllMidsceneLocatorField: ()=>findAllMidsceneLocatorField,
    loadActionParam: ()=>loadActionParam,
    fillBboxParam: ()=>fillBboxParam,
    adaptGeminiBbox: ()=>adaptGeminiBbox,
    mergeRects: ()=>mergeRects,
    RectSchema: ()=>RectSchema,
    PointSchema: ()=>PointSchema,
    adaptBboxToRect: ()=>adaptBboxToRect,
    markupImageForLLM: ()=>markupImageForLLM,
    adaptDoubaoBbox: ()=>adaptDoubaoBbox,
    callAiFn: ()=>callAiFn,
    dumpMidsceneLocatorField: ()=>dumpMidsceneLocatorField,
    adaptQwenBbox: ()=>adaptQwenBbox,
    buildYamlFlowFromPlans: ()=>buildYamlFlowFromPlans,
    getMidsceneLocationSchema: ()=>getMidsceneLocationSchema,
    ifMidsceneLocatorField: ()=>ifMidsceneLocatorField,
    dumpActionParam: ()=>dumpActionParam,
    warnGPT4oSizeLimit: ()=>warnGPT4oSizeLimit
});
const utils_namespaceObject = require("@midscene/shared/utils");
const index_js_namespaceObject = require("./service-caller/index.js");
const constants_namespaceObject = require("@midscene/shared/constants");
const env_namespaceObject = require("@midscene/shared/env");
const extractor_namespaceObject = require("@midscene/shared/extractor");
const img_namespaceObject = require("@midscene/shared/img");
const logger_namespaceObject = require("@midscene/shared/logger");
const external_zod_namespaceObject = require("zod");
var common_AIActionType = /*#__PURE__*/ function(AIActionType) {
    AIActionType[AIActionType["ASSERT"] = 0] = "ASSERT";
    AIActionType[AIActionType["INSPECT_ELEMENT"] = 1] = "INSPECT_ELEMENT";
    AIActionType[AIActionType["EXTRACT_DATA"] = 2] = "EXTRACT_DATA";
    AIActionType[AIActionType["PLAN"] = 3] = "PLAN";
    AIActionType[AIActionType["DESCRIBE_ELEMENT"] = 4] = "DESCRIBE_ELEMENT";
    return AIActionType;
}({});
async function callAiFn(msgs, AIActionTypeValue, modelPreferences) {
    const jsonObject = await (0, index_js_namespaceObject.callToGetJSONObject)(msgs, AIActionTypeValue, modelPreferences);
    return {
        content: jsonObject.content,
        usage: jsonObject.usage
    };
}
const defaultBboxSize = 20;
const debugInspectUtils = (0, logger_namespaceObject.getDebug)('ai:common');
function fillBboxParam(locate, width, height, modelPreferences) {
    if (locate.bbox_2d && !(null == locate ? void 0 : locate.bbox)) {
        locate.bbox = locate.bbox_2d;
        delete locate.bbox_2d;
    }
    if (null == locate ? void 0 : locate.bbox) locate.bbox = adaptBbox(locate.bbox, width, height, modelPreferences);
    return locate;
}
function adaptQwenBbox(bbox) {
    if (bbox.length < 2) {
        const msg = `invalid bbox data for qwen-vl mode: ${JSON.stringify(bbox)} `;
        throw new Error(msg);
    }
    const result = [
        Math.round(bbox[0]),
        Math.round(bbox[1]),
        'number' == typeof bbox[2] ? Math.round(bbox[2]) : Math.round(bbox[0] + defaultBboxSize),
        'number' == typeof bbox[3] ? Math.round(bbox[3]) : Math.round(bbox[1] + defaultBboxSize)
    ];
    return result;
}
function adaptDoubaoBbox(bbox, width, height) {
    (0, utils_namespaceObject.assert)(width > 0 && height > 0, 'width and height must be greater than 0 in doubao mode');
    if ('string' == typeof bbox) {
        (0, utils_namespaceObject.assert)(/^(\d+)\s(\d+)\s(\d+)\s(\d+)$/.test(bbox.trim()), `invalid bbox data string for doubao-vision mode: ${bbox}`);
        const splitted = bbox.split(' ');
        if (4 === splitted.length) return [
            Math.round(Number(splitted[0]) * width / 1000),
            Math.round(Number(splitted[1]) * height / 1000),
            Math.round(Number(splitted[2]) * width / 1000),
            Math.round(Number(splitted[3]) * height / 1000)
        ];
        throw new Error(`invalid bbox data string for doubao-vision mode: ${bbox}`);
    }
    if (Array.isArray(bbox) && Array.isArray(bbox[0])) bbox = bbox[0];
    let bboxList = [];
    if (Array.isArray(bbox) && 'string' == typeof bbox[0]) bbox.forEach((item)=>{
        if ('string' == typeof item && item.includes(',')) {
            const [x, y] = item.split(',');
            bboxList.push(Number(x.trim()), Number(y.trim()));
        } else if ('string' == typeof item && item.includes(' ')) {
            const [x, y] = item.split(' ');
            bboxList.push(Number(x.trim()), Number(y.trim()));
        } else bboxList.push(Number(item));
    });
    else bboxList = bbox;
    if (4 === bboxList.length || 5 === bboxList.length) return [
        Math.round(bboxList[0] * width / 1000),
        Math.round(bboxList[1] * height / 1000),
        Math.round(bboxList[2] * width / 1000),
        Math.round(bboxList[3] * height / 1000)
    ];
    if (6 === bboxList.length || 2 === bboxList.length || 3 === bboxList.length || 7 === bboxList.length) return [
        Math.max(0, Math.round(bboxList[0] * width / 1000) - defaultBboxSize / 2),
        Math.max(0, Math.round(bboxList[1] * height / 1000) - defaultBboxSize / 2),
        Math.min(width, Math.round(bboxList[0] * width / 1000) + defaultBboxSize / 2),
        Math.min(height, Math.round(bboxList[1] * height / 1000) + defaultBboxSize / 2)
    ];
    if (8 === bbox.length) return [
        Math.round(bboxList[0] * width / 1000),
        Math.round(bboxList[1] * height / 1000),
        Math.round(bboxList[4] * width / 1000),
        Math.round(bboxList[5] * height / 1000)
    ];
    const msg = `invalid bbox data for doubao-vision mode: ${JSON.stringify(bbox)} `;
    throw new Error(msg);
}
function adaptBbox(bbox, width, height, modelPreferences) {
    if ('doubao-vision' === (0, env_namespaceObject.vlLocateMode)(modelPreferences) || 'vlm-ui-tars' === (0, env_namespaceObject.vlLocateMode)(modelPreferences)) return adaptDoubaoBbox(bbox, width, height);
    if ('gemini' === (0, env_namespaceObject.vlLocateMode)(modelPreferences)) return adaptGeminiBbox(bbox, width, height);
    return adaptQwenBbox(bbox);
}
function adaptGeminiBbox(bbox, width, height) {
    const left = Math.round(bbox[1] * width / 1000);
    const top = Math.round(bbox[0] * height / 1000);
    const right = Math.round(bbox[3] * width / 1000);
    const bottom = Math.round(bbox[2] * height / 1000);
    return [
        left,
        top,
        right,
        bottom
    ];
}
function adaptBboxToRect(bbox, width, height, modelPreferences, offsetX = 0, offsetY = 0) {
    debugInspectUtils('adaptBboxToRect', bbox, width, height, offsetX, offsetY);
    const [left, top, right, bottom] = adaptBbox(bbox, width, height, modelPreferences);
    const rect = {
        left: left + offsetX,
        top: top + offsetY,
        width: right - left,
        height: bottom - top
    };
    debugInspectUtils('adaptBboxToRect, result=', rect);
    return rect;
}
let warned = false;
function warnGPT4oSizeLimit(size, modelPreferences) {
    var _getModelName;
    if (warned) return;
    if (null == (_getModelName = (0, env_namespaceObject.getModelName)(modelPreferences)) ? void 0 : _getModelName.toLowerCase().includes('gpt-4o')) {
        const warningMsg = `GPT-4o has a maximum image input size of 2000x768 or 768x2000, but got ${size.width}x${size.height}. Please set your interface to a smaller resolution. Otherwise, the result may be inaccurate.`;
        if (Math.max(size.width, size.height) > 2000 || Math.min(size.width, size.height) > 768) {
            console.warn(warningMsg);
            warned = true;
        }
    } else if (size.width > 1800 || size.height > 1800) {
        console.warn(`The image size seems too large (${size.width}x${size.height}). It may lead to more token usage, slower response, and inaccurate result.`);
        warned = true;
    }
}
function mergeRects(rects) {
    const minLeft = Math.min(...rects.map((r)=>r.left));
    const minTop = Math.min(...rects.map((r)=>r.top));
    const maxRight = Math.max(...rects.map((r)=>r.left + r.width));
    const maxBottom = Math.max(...rects.map((r)=>r.top + r.height));
    return {
        left: minLeft,
        top: minTop,
        width: maxRight - minLeft,
        height: maxBottom - minTop
    };
}
function expandSearchArea(rect, screenSize, modelPreferences) {
    const minEdgeSize = 'doubao-vision' === (0, env_namespaceObject.vlLocateMode)(modelPreferences) ? 500 : 300;
    const defaultPadding = 160;
    const paddingSizeHorizontal = rect.width < minEdgeSize ? Math.ceil((minEdgeSize - rect.width) / 2) : defaultPadding;
    const paddingSizeVertical = rect.height < minEdgeSize ? Math.ceil((minEdgeSize - rect.height) / 2) : defaultPadding;
    rect.left = Math.max(0, rect.left - paddingSizeHorizontal);
    rect.width = Math.min(rect.width + 2 * paddingSizeHorizontal, screenSize.width - rect.left);
    rect.top = Math.max(0, rect.top - paddingSizeVertical);
    rect.height = Math.min(rect.height + 2 * paddingSizeVertical, screenSize.height - rect.top);
    return rect;
}
async function markupImageForLLM(screenshotBase64, tree, size) {
    const elementsInfo = (0, extractor_namespaceObject.treeToList)(tree);
    const elementsPositionInfoWithoutText = elementsInfo.filter((elementInfo)=>{
        if (elementInfo.attributes.nodeType === constants_namespaceObject.NodeType.TEXT) return false;
        return true;
    });
    const imagePayload = await (0, img_namespaceObject.compositeElementInfoImg)({
        inputImgBase64: screenshotBase64,
        elementsPositionInfo: elementsPositionInfoWithoutText,
        size
    });
    return imagePayload;
}
function buildYamlFlowFromPlans(plans, actionSpace, sleep) {
    const flow = [];
    for (const plan of plans){
        const verb = plan.type;
        const action = actionSpace.find((action)=>action.name === verb);
        if (!action) {
            console.warn(`Cannot convert action ${verb} to yaml flow. Will ignore it.`);
            continue;
        }
        const flowKey = action.interfaceAlias || verb;
        const flowParam = action.paramSchema ? dumpActionParam(plan.param || {}, action.paramSchema) : {};
        const flowItem = {
            [flowKey]: '',
            ...flowParam
        };
        flow.push(flowItem);
    }
    if (sleep) flow.push({
        sleep
    });
    return flow;
}
const PointSchema = external_zod_namespaceObject.z.object({
    left: external_zod_namespaceObject.z.number(),
    top: external_zod_namespaceObject.z.number()
});
const SizeSchema = external_zod_namespaceObject.z.object({
    width: external_zod_namespaceObject.z.number(),
    height: external_zod_namespaceObject.z.number(),
    dpr: external_zod_namespaceObject.z.number().optional()
});
const RectSchema = PointSchema.and(SizeSchema).and(external_zod_namespaceObject.z.object({
    zoom: external_zod_namespaceObject.z.number().optional()
}));
const TMultimodalPromptSchema = external_zod_namespaceObject.z.object({
    images: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.object({
        name: external_zod_namespaceObject.z.string(),
        url: external_zod_namespaceObject.z.string()
    })).optional(),
    convertHttpImage2Base64: external_zod_namespaceObject.z.boolean().optional()
});
const TUserPromptSchema = external_zod_namespaceObject.z.union([
    external_zod_namespaceObject.z.string(),
    external_zod_namespaceObject.z.object({
        prompt: external_zod_namespaceObject.z.string()
    }).and(TMultimodalPromptSchema.partial())
]);
const locateFieldFlagName = 'midscene_location_field_flag';
const MidsceneLocationResult = external_zod_namespaceObject.z.object({
    [locateFieldFlagName]: external_zod_namespaceObject.z.literal(true),
    prompt: TUserPromptSchema,
    deepThink: external_zod_namespaceObject.z.boolean().optional(),
    cacheable: external_zod_namespaceObject.z.boolean().optional(),
    xpath: external_zod_namespaceObject.z.boolean().optional(),
    center: external_zod_namespaceObject.z.tuple([
        external_zod_namespaceObject.z.number(),
        external_zod_namespaceObject.z.number()
    ]),
    rect: RectSchema
}).passthrough();
const getMidsceneLocationSchema = ()=>MidsceneLocationResult;
const ifMidsceneLocatorField = (field)=>{
    var _actualField__def, _actualField__def1;
    let actualField = field;
    if ((null == (_actualField__def = actualField._def) ? void 0 : _actualField__def.typeName) === 'ZodOptional') actualField = actualField._def.innerType;
    if ((null == (_actualField__def1 = actualField._def) ? void 0 : _actualField__def1.typeName) === 'ZodObject') {
        const shape = actualField._def.shape();
        return locateFieldFlagName in shape;
    }
    return false;
};
const dumpMidsceneLocatorField = (field)=>{
    (0, utils_namespaceObject.assert)(ifMidsceneLocatorField(field), 'field is not a midscene locator field');
    if ('string' == typeof field) return field;
    if (field && 'object' == typeof field && field.prompt) {
        if ('string' == typeof field.prompt) return field.prompt;
        if ('object' == typeof field.prompt && field.prompt.prompt) return field.prompt.prompt;
    }
    return String(field);
};
const findAllMidsceneLocatorField = (zodType, requiredOnly)=>{
    var _zodObject__def;
    if (!zodType) return [];
    const zodObject = zodType;
    if ((null == (_zodObject__def = zodObject._def) ? void 0 : _zodObject__def.typeName) === 'ZodObject' && zodObject.shape) {
        const keys = Object.keys(zodObject.shape);
        return keys.filter((key)=>{
            const field = zodObject.shape[key];
            if (!ifMidsceneLocatorField(field)) return false;
            if (requiredOnly) {
                var _field__def;
                return (null == (_field__def = field._def) ? void 0 : _field__def.typeName) !== 'ZodOptional';
            }
            return true;
        });
    }
    return [];
};
const dumpActionParam = (jsonObject, zodSchema)=>{
    const locatorFields = findAllMidsceneLocatorField(zodSchema);
    const result = {
        ...jsonObject
    };
    for (const fieldName of locatorFields){
        const fieldValue = result[fieldName];
        if (fieldValue) {
            if ('string' == typeof fieldValue) result[fieldName] = fieldValue;
            else if ('object' == typeof fieldValue) {
                if (fieldValue.prompt) {
                    if ('string' == typeof fieldValue.prompt) result[fieldName] = fieldValue.prompt;
                    else if ('object' == typeof fieldValue.prompt && fieldValue.prompt.prompt) result[fieldName] = fieldValue.prompt.prompt;
                }
            }
        }
    }
    return result;
};
const loadActionParam = (jsonObject, zodSchema)=>{
    const locatorFields = findAllMidsceneLocatorField(zodSchema);
    const result = {
        ...jsonObject
    };
    for (const fieldName of locatorFields){
        const fieldValue = result[fieldName];
        if (fieldValue && 'string' == typeof fieldValue) result[fieldName] = {
            [locateFieldFlagName]: true,
            prompt: fieldValue
        };
    }
    return result;
};
exports.AIActionType = __webpack_exports__.AIActionType;
exports.PointSchema = __webpack_exports__.PointSchema;
exports.RectSchema = __webpack_exports__.RectSchema;
exports.SizeSchema = __webpack_exports__.SizeSchema;
exports.TMultimodalPromptSchema = __webpack_exports__.TMultimodalPromptSchema;
exports.TUserPromptSchema = __webpack_exports__.TUserPromptSchema;
exports.adaptBbox = __webpack_exports__.adaptBbox;
exports.adaptBboxToRect = __webpack_exports__.adaptBboxToRect;
exports.adaptDoubaoBbox = __webpack_exports__.adaptDoubaoBbox;
exports.adaptGeminiBbox = __webpack_exports__.adaptGeminiBbox;
exports.adaptQwenBbox = __webpack_exports__.adaptQwenBbox;
exports.buildYamlFlowFromPlans = __webpack_exports__.buildYamlFlowFromPlans;
exports.callAiFn = __webpack_exports__.callAiFn;
exports.dumpActionParam = __webpack_exports__.dumpActionParam;
exports.dumpMidsceneLocatorField = __webpack_exports__.dumpMidsceneLocatorField;
exports.expandSearchArea = __webpack_exports__.expandSearchArea;
exports.fillBboxParam = __webpack_exports__.fillBboxParam;
exports.findAllMidsceneLocatorField = __webpack_exports__.findAllMidsceneLocatorField;
exports.getMidsceneLocationSchema = __webpack_exports__.getMidsceneLocationSchema;
exports.ifMidsceneLocatorField = __webpack_exports__.ifMidsceneLocatorField;
exports.loadActionParam = __webpack_exports__.loadActionParam;
exports.markupImageForLLM = __webpack_exports__.markupImageForLLM;
exports.mergeRects = __webpack_exports__.mergeRects;
exports.warnGPT4oSizeLimit = __webpack_exports__.warnGPT4oSizeLimit;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "AIActionType",
    "PointSchema",
    "RectSchema",
    "SizeSchema",
    "TMultimodalPromptSchema",
    "TUserPromptSchema",
    "adaptBbox",
    "adaptBboxToRect",
    "adaptDoubaoBbox",
    "adaptGeminiBbox",
    "adaptQwenBbox",
    "buildYamlFlowFromPlans",
    "callAiFn",
    "dumpActionParam",
    "dumpMidsceneLocatorField",
    "expandSearchArea",
    "fillBboxParam",
    "findAllMidsceneLocatorField",
    "getMidsceneLocationSchema",
    "ifMidsceneLocatorField",
    "loadActionParam",
    "markupImageForLLM",
    "mergeRects",
    "warnGPT4oSizeLimit"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=common.js.map