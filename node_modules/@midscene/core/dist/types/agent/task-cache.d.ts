import type { TUserPrompt } from '../index';
export declare const debug: import("@midscene/shared/logger").DebugFunction;
export interface PlanningCache {
    type: 'plan';
    prompt: string;
    yamlWorkflow: string;
}
export interface LocateCache {
    type: 'locate';
    prompt: TUserPrompt;
    xpaths: string[];
}
export interface MatchCacheResult<T extends PlanningCache | LocateCache> {
    cacheContent: T;
    updateFn: (cb: (cache: T) => void) => void;
}
export type CacheFileContent = {
    midsceneVersion: string;
    cacheId: string;
    caches: Array<PlanningCache | LocateCache>;
};
export declare const cacheFileExt = ".cache.yaml";
export declare class TaskCache {
    cacheId: string;
    cacheFilePath?: string;
    cache: CacheFileContent;
    isCacheResultUsed: boolean;
    cacheOriginalLength: number;
    private matchedCacheIndices;
    constructor(cacheId: string, isCacheResultUsed: boolean, cacheFilePath?: string);
    matchCache(prompt: TUserPrompt, type: 'plan' | 'locate'): MatchCacheResult<PlanningCache | LocateCache> | undefined;
    matchPlanCache(prompt: string): MatchCacheResult<PlanningCache> | undefined;
    matchLocateCache(prompt: TUserPrompt): MatchCacheResult<LocateCache> | undefined;
    appendCache(cache: PlanningCache | LocateCache): void;
    loadCacheFromFile(): CacheFileContent | undefined;
    flushCacheToFile(): void;
    updateOrAppendCacheRecord(newRecord: PlanningCache | LocateCache, cachedRecord?: MatchCacheResult<PlanningCache | LocateCache>): void;
}
