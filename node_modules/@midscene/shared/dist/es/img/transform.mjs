import node_assert from "node:assert";
import { Buffer } from "node:buffer";
import { readFileSync } from "node:fs";
import node_path from "node:path";
import { getDebug } from "../logger.mjs";
import { ifInNode } from "../utils.mjs";
import get_jimp from "./get-jimp.mjs";
import get_photon from "./get-photon.mjs";
import get_sharp from "./get-sharp.mjs";
const imgDebug = getDebug('img');
async function saveBase64Image(options) {
    const { base64Data, outputPath } = options;
    const { body } = parseBase64(base64Data);
    const imageBuffer = Buffer.from(body, 'base64');
    const Jimp = await get_jimp();
    const image = await Jimp.read(imageBuffer);
    await image.writeAsync(outputPath);
}
async function resizeAndConvertImgBuffer(inputFormat, inputData, newSize) {
    if ('string' == typeof inputData) throw Error('inputData is base64, use resizeImgBase64 instead');
    node_assert(newSize && newSize.width > 0 && newSize.height > 0, 'newSize must be positive');
    const resizeStartTime = Date.now();
    imgDebug(`resizeImg start, target size: ${newSize.width}x${newSize.height}`);
    if (ifInNode) try {
        const Sharp = await get_sharp();
        const metadata = await Sharp(inputData).metadata();
        const { width: originalWidth, height: originalHeight } = metadata;
        if (!originalWidth || !originalHeight) throw Error('Undefined width or height from the input image.');
        if (newSize.width === originalWidth && newSize.height === originalHeight) return {
            buffer: inputData,
            format: inputFormat
        };
        const resizedBuffer = await Sharp(inputData).resize(newSize.width, newSize.height).jpeg({
            quality: 90
        }).toBuffer();
        const resizeEndTime = Date.now();
        imgDebug(`resizeImg done (Sharp), target size: ${newSize.width}x${newSize.height}, cost: ${resizeEndTime - resizeStartTime}ms`);
        return {
            buffer: resizedBuffer,
            format: 'jpeg'
        };
    } catch (error) {
        imgDebug('Sharp failed, falling back to Photon:', error);
    }
    const { PhotonImage, SamplingFilter, resize } = await get_photon();
    const inputBytes = new Uint8Array(inputData);
    const inputImage = PhotonImage.new_from_byteslice(inputBytes);
    const originalWidth = inputImage.get_width();
    const originalHeight = inputImage.get_height();
    if (!originalWidth || !originalHeight) {
        inputImage.free();
        throw Error('Undefined width or height from the input image.');
    }
    if (newSize.width === originalWidth && newSize.height === originalHeight) {
        inputImage.free();
        return {
            buffer: inputData,
            format: inputFormat
        };
    }
    const outputImage = resize(inputImage, newSize.width, newSize.height, SamplingFilter.CatmullRom);
    const outputBytes = outputImage.get_bytes_jpeg(90);
    const resizedBuffer = Buffer.from(outputBytes);
    inputImage.free();
    outputImage.free();
    const resizeEndTime = Date.now();
    imgDebug(`resizeImg done (Photon), target size: ${newSize.width}x${newSize.height}, cost: ${resizeEndTime - resizeStartTime}ms`);
    return {
        buffer: resizedBuffer,
        format: 'jpeg'
    };
}
const createImgBase64ByFormat = (format, body)=>`data:image/${format};base64,${body}`;
async function resizeImgBase64(inputBase64, newSize) {
    const { body, mimeType } = parseBase64(inputBase64);
    const imageBuffer = Buffer.from(body, 'base64');
    const { buffer, format } = await resizeAndConvertImgBuffer(mimeType.split('/')[1], imageBuffer, newSize);
    return createImgBase64ByFormat(format, buffer.toString('base64'));
}
function zoomForGPT4o(originalWidth, originalHeight) {
    const maxWidth = 2048;
    const maxHeight = 768;
    let newWidth = originalWidth;
    let newHeight = originalHeight;
    const aspectRatio = originalWidth / originalHeight;
    if (originalWidth > maxWidth) {
        newWidth = maxWidth;
        newHeight = newWidth / aspectRatio;
    }
    if (newHeight > maxHeight) {
        newHeight = maxHeight;
        newWidth = newHeight * aspectRatio;
    }
    return {
        width: Math.round(newWidth),
        height: Math.round(newHeight)
    };
}
async function jimpFromBase64(base64) {
    const Jimp = await get_jimp();
    const { body } = parseBase64(base64);
    const imageBuffer = Buffer.from(body, 'base64');
    return Jimp.read(imageBuffer);
}
async function paddingToMatchBlock(image, blockSize = 28) {
    const { width, height } = image.bitmap;
    const targetWidth = Math.ceil(width / blockSize) * blockSize;
    const targetHeight = Math.ceil(height / blockSize) * blockSize;
    if (targetWidth === width && targetHeight === height) return image;
    const Jimp = await get_jimp();
    const paddedImage = new Jimp(targetWidth, targetHeight, 0xffffffff);
    paddedImage.composite(image, 0, 0);
    return paddedImage;
}
async function paddingToMatchBlockByBase64(imageBase64, blockSize = 28) {
    const jimpImage = await jimpFromBase64(imageBase64);
    const paddedImage = await paddingToMatchBlock(jimpImage, blockSize);
    return jimpToBase64(paddedImage);
}
async function cropByRect(imageBase64, rect, paddingImage) {
    const jimpImage = await jimpFromBase64(imageBase64);
    const { left, top, width, height } = rect;
    jimpImage.crop(left, top, width, height);
    if (paddingImage) {
        const paddedImage = await paddingToMatchBlock(jimpImage);
        return jimpToBase64(paddedImage);
    }
    return jimpToBase64(jimpImage);
}
async function jimpToBase64(image) {
    const Jimp = await get_jimp();
    return image.getBase64Async(Jimp.MIME_JPEG);
}
const httpImg2Base64 = async (url)=>{
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch image: ${url}`);
    const contentType = response.headers.get('content-type');
    if (!contentType) throw new Error(`Failed to fetch image: ${url}`);
    node_assert(contentType.startsWith('image/'), `The url ${url} is not a image, because of content-type in header is ${contentType}.`);
    const buffer = Buffer.from(await response.arrayBuffer());
    return `data:${contentType};base64,${buffer.toString('base64')}`;
};
const localImg2Base64 = (imgPath, withoutHeader = false)=>{
    const body = readFileSync(imgPath).toString('base64');
    if (withoutHeader) return body;
    const type = node_path.extname(imgPath).slice(1);
    const finalType = 'svg' === type ? 'svg+xml' : type || 'jpg';
    return `data:image/${finalType};base64,${body}`;
};
const preProcessImageUrl = async (url, convertHttpImage2Base64)=>{
    if ('string' != typeof url) throw new Error(`url must be a string, but got ${url} with type ${typeof url}`);
    if (url.startsWith('data:')) return url;
    if (!(url.startsWith('http://') || url.startsWith('https://'))) return await localImg2Base64(url);
    if (!convertHttpImage2Base64) return url;
    return await httpImg2Base64(url);
};
const parseBase64 = (fullBase64String)=>{
    try {
        const separator = ';base64,';
        const index = fullBase64String.indexOf(separator);
        if (-1 === index) throw new Error('Invalid base64 string');
        return {
            mimeType: fullBase64String.slice(5, index),
            body: fullBase64String.slice(index + separator.length)
        };
    } catch (e) {
        throw new Error(`parseBase64 fail because intput is not a valid base64 string: ${fullBase64String}`, {
            cause: e
        });
    }
};
export { createImgBase64ByFormat, cropByRect, httpImg2Base64, jimpFromBase64, jimpToBase64, localImg2Base64, paddingToMatchBlock, paddingToMatchBlockByBase64, parseBase64, preProcessImageUrl, resizeAndConvertImgBuffer, resizeImgBase64, saveBase64Image, zoomForGPT4o };
