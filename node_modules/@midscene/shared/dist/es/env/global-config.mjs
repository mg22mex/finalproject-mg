import { getDebug } from "../logger.mjs";
import { initDebugConfig } from "./init-debug.mjs";
import { decideModelConfig } from "./model-config.mjs";
import { ALL_ENV_KEYS, BOOLEAN_ENV_KEYS, GLOBAL_ENV_KEYS, MATCH_BY_POSITION, MODEL_ENV_KEYS, NUMBER_ENV_KEYS, STRING_ENV_KEYS } from "./types.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const allConfigFromEnv = ()=>ALL_ENV_KEYS.reduce((p, name)=>({
            ...p,
            [name]: process.env[name]
        }), Object.create(null));
const GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG = 'GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG';
const isInChromeExtension = ()=>'undefined' != typeof chrome && chrome.runtime.id;
const ALL_INTENTS = [
    'VQA',
    'default',
    'grounding',
    'planning'
];
class GlobalConfigManager {
    initAllEnvConfig() {
        const envConfig = allConfigFromEnv();
        this.allEnvConfig = (()=>{
            if (this.override) {
                this.debugLog('initAllConfig with override from overrideAIConfig');
                const { newConfig, extendMode } = this.override;
                if (extendMode) {
                    this.debugLog('initAllConfig with extend mode from overrideAIConfig');
                    return {
                        ...envConfig,
                        ...newConfig
                    };
                }
                this.debugLog('initAllConfig without override mode from overrideAIConfig');
                return {
                    ...newConfig
                };
            }
            this.debugLog('initAllConfig without override from overrideAIConfig');
            return envConfig;
        })();
    }
    initIntentConfigFromFn() {
        const intentConfigFromFn = {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        };
        if (this.latestModelConfigFn) for (const i of ALL_INTENTS){
            const result = this.latestModelConfigFn({
                intent: i
            });
            if (!result) throw new Error(`The agent has an option named modelConfig is a function, but it return ${result} when call with intent ${i}, which should be a object.`);
            intentConfigFromFn[i] = result;
        }
        return intentConfigFromFn;
    }
    createUninitializedError(message) {
        const error = new Error(message);
        error[GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG] = true;
        return error;
    }
    reset() {
        console.warn('globalConfigManager.reset should only be called in Midscene owner unit test');
        this.initialized = false;
        this.override = void 0;
        this.allEnvConfig = void 0;
        this.keysHaveBeenRead = {};
        this.modelConfigByIntent = {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        };
    }
    initModelConfigForIntent() {
        this.initAllEnvConfig();
        const intentConfigFromFn = this.initIntentConfigFromFn();
        for (const i of ALL_INTENTS){
            const result = decideModelConfig({
                intent: i,
                allConfig: this.allEnvConfig,
                modelConfigFromFn: intentConfigFromFn[i]
            });
            this.modelConfigByIntent[i] = result;
        }
    }
    initModelConfigForChromeExtension() {
        this.initAllEnvConfig();
        this.modelConfigForChromeExtension = decideModelConfig({
            intent: 'default',
            allConfig: this.allEnvConfig,
            modelConfigFromFn: void 0
        });
    }
    init(modelConfigFn) {
        this.latestModelConfigFn = modelConfigFn;
        this.initModelConfigForIntent();
        this.initialized = true;
    }
    getModelConfigByIntent(intent) {
        if (!this.initialized) {
            if (isInChromeExtension()) {
                console.warn('globalConfigManager is not initialized but was called in chrome Extension, will get model config from env');
                if (!this.modelConfigForChromeExtension) this.initModelConfigForChromeExtension();
                return this.modelConfigForChromeExtension;
            }
            throw this.createUninitializedError(`globalConfigManager is not initialized when call getModelConfigByIntent with intent ${intent}`);
        }
        return this.modelConfigByIntent[intent];
    }
    getEnvConfigValue(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!STRING_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigValue with key ${key} is not supported.`);
        if (key === MATCH_BY_POSITION) throw new Error('MATCH_BY_POSITION is deprecated, use MIDSCENE_USE_VL_MODEL instead');
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        if ('string' == typeof value) return value.trim();
        return value;
    }
    getEnvConfigInNumber(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!NUMBER_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigInNumber with key ${key} is not supported`);
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        return Number(value || '');
    }
    getEnvConfigInBoolean(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!BOOLEAN_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigInBoolean with key ${key} is not supported`);
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        if (!value) return false;
        if (/^(true|1)$/i.test(value)) return true;
        if (/^(false|0)$/i.test(value)) return false;
        return !!value.trim();
    }
    registerOverride(newConfig, extendMode = false) {
        var _this_override;
        for(const key in newConfig){
            if (![
                ...GLOBAL_ENV_KEYS,
                ...MODEL_ENV_KEYS
            ].includes(key)) throw new Error(`Failed to override AI config, invalid key: ${key}`);
            const value = newConfig[key];
            if ('string' != typeof value) throw new Error(`Failed to override AI config, value for key ${key} must be a string, but got with type ${typeof value}`);
            if (this.keysHaveBeenRead[key]) console.warn(`Warning: try to override AI config with key ${key} ,but it has been read.`);
        }
        const savedNewConfig = extendMode ? {
            ...null == (_this_override = this.override) ? void 0 : _this_override.newConfig,
            ...newConfig
        } : newConfig;
        this.override = {
            newConfig: {
                ...savedNewConfig
            },
            extendMode
        };
        if (this.initialized) this.initModelConfigForIntent();
        else {
            this.initAllEnvConfig();
            this.modelConfigForChromeExtension = void 0;
        }
    }
    constructor(){
        _define_property(this, "override", void 0);
        _define_property(this, "initialized", false);
        _define_property(this, "debugLog", void 0);
        _define_property(this, "modelConfigByIntent", {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        });
        _define_property(this, "allEnvConfig", void 0);
        _define_property(this, "keysHaveBeenRead", {});
        _define_property(this, "latestModelConfigFn", void 0);
        _define_property(this, "modelConfigForChromeExtension", void 0);
        initDebugConfig();
        const debugLog = getDebug('ai:global-config');
        this.debugLog = debugLog;
    }
}
export { GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG, GlobalConfigManager };
