"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG: ()=>GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG,
    GlobalConfigManager: ()=>GlobalConfigManager
});
const external_logger_js_namespaceObject = require("../logger.js");
const external_init_debug_js_namespaceObject = require("./init-debug.js");
const external_model_config_js_namespaceObject = require("./model-config.js");
const external_types_js_namespaceObject = require("./types.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const allConfigFromEnv = ()=>external_types_js_namespaceObject.ALL_ENV_KEYS.reduce((p, name)=>({
            ...p,
            [name]: process.env[name]
        }), Object.create(null));
const GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG = 'GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG';
const isInChromeExtension = ()=>'undefined' != typeof chrome && chrome.runtime.id;
const ALL_INTENTS = [
    'VQA',
    'default',
    'grounding',
    'planning'
];
class GlobalConfigManager {
    initAllEnvConfig() {
        const envConfig = allConfigFromEnv();
        this.allEnvConfig = (()=>{
            if (this.override) {
                this.debugLog('initAllConfig with override from overrideAIConfig');
                const { newConfig, extendMode } = this.override;
                if (extendMode) {
                    this.debugLog('initAllConfig with extend mode from overrideAIConfig');
                    return {
                        ...envConfig,
                        ...newConfig
                    };
                }
                this.debugLog('initAllConfig without override mode from overrideAIConfig');
                return {
                    ...newConfig
                };
            }
            this.debugLog('initAllConfig without override from overrideAIConfig');
            return envConfig;
        })();
    }
    initIntentConfigFromFn() {
        const intentConfigFromFn = {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        };
        if (this.latestModelConfigFn) for (const i of ALL_INTENTS){
            const result = this.latestModelConfigFn({
                intent: i
            });
            if (!result) throw new Error(`The agent has an option named modelConfig is a function, but it return ${result} when call with intent ${i}, which should be a object.`);
            intentConfigFromFn[i] = result;
        }
        return intentConfigFromFn;
    }
    createUninitializedError(message) {
        const error = new Error(message);
        error[GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG] = true;
        return error;
    }
    reset() {
        console.warn('globalConfigManager.reset should only be called in Midscene owner unit test');
        this.initialized = false;
        this.override = void 0;
        this.allEnvConfig = void 0;
        this.keysHaveBeenRead = {};
        this.modelConfigByIntent = {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        };
    }
    initModelConfigForIntent() {
        this.initAllEnvConfig();
        const intentConfigFromFn = this.initIntentConfigFromFn();
        for (const i of ALL_INTENTS){
            const result = (0, external_model_config_js_namespaceObject.decideModelConfig)({
                intent: i,
                allConfig: this.allEnvConfig,
                modelConfigFromFn: intentConfigFromFn[i]
            });
            this.modelConfigByIntent[i] = result;
        }
    }
    initModelConfigForChromeExtension() {
        this.initAllEnvConfig();
        this.modelConfigForChromeExtension = (0, external_model_config_js_namespaceObject.decideModelConfig)({
            intent: 'default',
            allConfig: this.allEnvConfig,
            modelConfigFromFn: void 0
        });
    }
    init(modelConfigFn) {
        this.latestModelConfigFn = modelConfigFn;
        this.initModelConfigForIntent();
        this.initialized = true;
    }
    getModelConfigByIntent(intent) {
        if (!this.initialized) {
            if (isInChromeExtension()) {
                console.warn('globalConfigManager is not initialized but was called in chrome Extension, will get model config from env');
                if (!this.modelConfigForChromeExtension) this.initModelConfigForChromeExtension();
                return this.modelConfigForChromeExtension;
            }
            throw this.createUninitializedError(`globalConfigManager is not initialized when call getModelConfigByIntent with intent ${intent}`);
        }
        return this.modelConfigByIntent[intent];
    }
    getEnvConfigValue(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!external_types_js_namespaceObject.STRING_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigValue with key ${key} is not supported.`);
        if (key === external_types_js_namespaceObject.MATCH_BY_POSITION) throw new Error('MATCH_BY_POSITION is deprecated, use MIDSCENE_USE_VL_MODEL instead');
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        if ('string' == typeof value) return value.trim();
        return value;
    }
    getEnvConfigInNumber(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!external_types_js_namespaceObject.NUMBER_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigInNumber with key ${key} is not supported`);
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        return Number(value || '');
    }
    getEnvConfigInBoolean(key) {
        const allConfig = this.allEnvConfig || process.env;
        if (!external_types_js_namespaceObject.BOOLEAN_ENV_KEYS.includes(key)) throw new Error(`getEnvConfigInBoolean with key ${key} is not supported`);
        const value = allConfig[key];
        this.keysHaveBeenRead[key] = true;
        if (!value) return false;
        if (/^(true|1)$/i.test(value)) return true;
        if (/^(false|0)$/i.test(value)) return false;
        return !!value.trim();
    }
    registerOverride(newConfig, extendMode = false) {
        var _this_override;
        for(const key in newConfig){
            if (![
                ...external_types_js_namespaceObject.GLOBAL_ENV_KEYS,
                ...external_types_js_namespaceObject.MODEL_ENV_KEYS
            ].includes(key)) throw new Error(`Failed to override AI config, invalid key: ${key}`);
            const value = newConfig[key];
            if ('string' != typeof value) throw new Error(`Failed to override AI config, value for key ${key} must be a string, but got with type ${typeof value}`);
            if (this.keysHaveBeenRead[key]) console.warn(`Warning: try to override AI config with key ${key} ,but it has been read.`);
        }
        const savedNewConfig = extendMode ? {
            ...null == (_this_override = this.override) ? void 0 : _this_override.newConfig,
            ...newConfig
        } : newConfig;
        this.override = {
            newConfig: {
                ...savedNewConfig
            },
            extendMode
        };
        if (this.initialized) this.initModelConfigForIntent();
        else {
            this.initAllEnvConfig();
            this.modelConfigForChromeExtension = void 0;
        }
    }
    constructor(){
        _define_property(this, "override", void 0);
        _define_property(this, "initialized", false);
        _define_property(this, "debugLog", void 0);
        _define_property(this, "modelConfigByIntent", {
            VQA: void 0,
            default: void 0,
            grounding: void 0,
            planning: void 0
        });
        _define_property(this, "allEnvConfig", void 0);
        _define_property(this, "keysHaveBeenRead", {});
        _define_property(this, "latestModelConfigFn", void 0);
        _define_property(this, "modelConfigForChromeExtension", void 0);
        (0, external_init_debug_js_namespaceObject.initDebugConfig)();
        const debugLog = (0, external_logger_js_namespaceObject.getDebug)('ai:global-config');
        this.debugLog = debugLog;
    }
}
exports.GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG = __webpack_exports__.GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG;
exports.GlobalConfigManager = __webpack_exports__.GlobalConfigManager;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "GLOBAL_CONFIG_MANAGER_UNINITIALIZED_FLAG",
    "GlobalConfigManager"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
