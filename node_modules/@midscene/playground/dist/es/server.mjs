import { randomUUID } from "node:crypto";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { getTmpDir } from "@midscene/core/utils";
import { PLAYGROUND_SERVER_PORT } from "@midscene/shared/constants";
import { overrideAIConfig } from "@midscene/shared/env";
import { ifInBrowser, ifInWorker } from "@midscene/shared/utils";
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import { executeAction, formatErrorMessage } from "./common.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const defaultPort = PLAYGROUND_SERVER_PORT;
const errorHandler = (err, req, res, next)=>{
    console.error(err);
    res.status(500).json({
        error: err.message
    });
};
const setup = async ()=>{
    if (!ifInBrowser && !ifInWorker) dotenv.config();
};
class PlaygroundServer {
    filePathForUuid(uuid) {
        return join(this.tmpDir, `${uuid}.json`);
    }
    saveContextFile(uuid, context) {
        const tmpFile = this.filePathForUuid(uuid);
        console.log(`save context file: ${tmpFile}`);
        writeFileSync(tmpFile, context);
        return tmpFile;
    }
    async launch(port) {
        this.port = port || defaultPort;
        this.app.use(errorHandler);
        this.app.use(cors({
            origin: '*',
            credentials: true
        }));
        this.app.get('/status', async (req, res)=>{
            res.send({
                status: 'ok'
            });
        });
        this.app.get('/context/:uuid', async (req, res)=>{
            const { uuid } = req.params;
            const contextFile = this.filePathForUuid(uuid);
            if (!existsSync(contextFile)) return res.status(404).json({
                error: 'Context not found'
            });
            const context = readFileSync(contextFile, 'utf8');
            res.json({
                context
            });
        });
        this.app.get('/task-progress/:requestId', async (req, res)=>{
            const { requestId } = req.params;
            res.json({
                tip: this.taskProgressTips[requestId] || ''
            });
        });
        this.app.post('/action-space', express.json({
            limit: '30mb'
        }), async (req, res)=>{
            const { context } = req.body;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            try {
                const page = new this.pageClass(context);
                const actionSpace = await page.actionSpace();
                const processedActionSpace = actionSpace.map((action)=>{
                    if (action.paramSchema && 'object' == typeof action.paramSchema) {
                        let processedSchema = null;
                        try {
                            if (action.paramSchema.shape && 'object' == typeof action.paramSchema.shape) processedSchema = {
                                type: 'ZodObject',
                                shape: action.paramSchema.shape
                            };
                        } catch (e) {
                            console.warn('Failed to process paramSchema for action:', action.name, e);
                        }
                        return {
                            ...action,
                            paramSchema: processedSchema
                        };
                    }
                    return action;
                });
                res.json(processedActionSpace);
            } catch (error) {
                console.error('Failed to get action space:', error);
                res.status(500).json({
                    error: error.message
                });
            }
        });
        this.app.post('/playground-with-context', express.json({
            limit: '50mb'
        }), async (req, res)=>{
            const context = req.body.context;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            const uuid = randomUUID();
            this.saveContextFile(uuid, context);
            return res.json({
                location: `/playground/${uuid}`,
                uuid
            });
        });
        this.app.post('/execute', express.json({
            limit: '30mb'
        }), async (req, res)=>{
            const { context, type, prompt, params, requestId, deepThink, screenshotIncluded, domIncluded } = req.body;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            if (!type) return res.status(400).json({
                error: 'type is required'
            });
            const page = new this.pageClass(context);
            const agent = new this.agentClass(page);
            if (requestId) {
                this.taskProgressTips[requestId] = '';
                this.activeAgents[requestId] = agent;
                agent.onTaskStartTip = (tip)=>{
                    this.taskProgressTips[requestId] = tip;
                };
            }
            const response = {
                result: null,
                dump: null,
                error: null,
                reportHTML: null,
                requestId
            };
            const startTime = Date.now();
            try {
                const actionSpace = await page.actionSpace();
                const value = {
                    type,
                    prompt,
                    params
                };
                response.result = await executeAction(agent, type, actionSpace, value, {
                    deepThink: deepThink || false,
                    screenshotIncluded,
                    domIncluded
                });
            } catch (error) {
                response.error = formatErrorMessage(error);
            }
            try {
                response.dump = JSON.parse(agent.dumpDataString());
                response.reportHTML = agent.reportHTMLString() || null;
                agent.writeOutActionDumps();
                agent.destroy();
            } catch (error) {
                console.error(`write out dump failed: requestId: ${requestId}, ${error.message}`);
            }
            res.send(response);
            const timeCost = Date.now() - startTime;
            if (response.error) console.error(`handle request failed after ${timeCost}ms: requestId: ${requestId}, ${response.error}`);
            else console.log(`handle request done after ${timeCost}ms: requestId: ${requestId}`);
            if (requestId && this.activeAgents[requestId]) delete this.activeAgents[requestId];
        });
        this.app.get('/cancel/:requestId', async (req, res)=>{
            const { requestId } = req.params;
            if (!requestId) return res.status(400).json({
                error: 'requestId is required'
            });
            const agent = this.activeAgents[requestId];
            if (!agent) return res.status(404).json({
                error: 'No active agent found for this requestId'
            });
            try {
                await agent.destroy();
                delete this.activeAgents[requestId];
                res.json({
                    status: 'cancelled'
                });
            } catch (error) {
                console.error(`Failed to cancel agent: ${error.message}`);
                res.status(500).json({
                    error: `Failed to cancel: ${error.message}`
                });
            }
        });
        this.app.post('/config', express.json({
            limit: '1mb'
        }), async (req, res)=>{
            const { aiConfig } = req.body;
            if (!aiConfig || 'object' != typeof aiConfig) return res.status(400).json({
                error: 'aiConfig is required and must be an object'
            });
            try {
                overrideAIConfig(aiConfig);
                return res.json({
                    status: 'ok',
                    message: 'AI config updated successfully'
                });
            } catch (error) {
                console.error(`Failed to update AI config: ${error.message}`);
                return res.status(500).json({
                    error: `Failed to update AI config: ${error.message}`
                });
            }
        });
        if (this.staticPath) {
            this.app.get('/', (_req, res)=>{
                res.redirect('/index.html');
            });
            this.app.get('*', (req, res)=>{
                const requestedPath = join(this.staticPath, req.path);
                if (existsSync(requestedPath)) res.sendFile(requestedPath);
                else res.sendFile(join(this.staticPath, 'index.html'));
            });
        }
        return new Promise((resolve)=>{
            const port = this.port;
            this.server = this.app.listen(port, ()=>{
                resolve(this);
            });
        });
    }
    close() {
        if (this.server) return this.server.close();
    }
    constructor(pageClass, agentClass, staticPath){
        _define_property(this, "app", void 0);
        _define_property(this, "tmpDir", void 0);
        _define_property(this, "server", void 0);
        _define_property(this, "port", void 0);
        _define_property(this, "pageClass", void 0);
        _define_property(this, "agentClass", void 0);
        _define_property(this, "staticPath", void 0);
        _define_property(this, "taskProgressTips", void 0);
        _define_property(this, "activeAgents", void 0);
        this.app = express();
        this.tmpDir = getTmpDir();
        this.pageClass = pageClass;
        this.agentClass = agentClass;
        this.staticPath = staticPath;
        this.taskProgressTips = {};
        this.activeAgents = {};
        setup();
    }
}
export { PlaygroundServer as default };

//# sourceMappingURL=server.mjs.map