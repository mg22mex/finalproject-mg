"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    default: ()=>PlaygroundServer
});
const external_node_crypto_namespaceObject = require("node:crypto");
const external_node_fs_namespaceObject = require("node:fs");
const external_node_path_namespaceObject = require("node:path");
const utils_namespaceObject = require("@midscene/core/utils");
const constants_namespaceObject = require("@midscene/shared/constants");
const env_namespaceObject = require("@midscene/shared/env");
const shared_utils_namespaceObject = require("@midscene/shared/utils");
const external_cors_namespaceObject = require("cors");
var external_cors_default = /*#__PURE__*/ __webpack_require__.n(external_cors_namespaceObject);
const external_dotenv_namespaceObject = require("dotenv");
var external_dotenv_default = /*#__PURE__*/ __webpack_require__.n(external_dotenv_namespaceObject);
const external_express_namespaceObject = require("express");
var external_express_default = /*#__PURE__*/ __webpack_require__.n(external_express_namespaceObject);
const external_common_js_namespaceObject = require("./common.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const defaultPort = constants_namespaceObject.PLAYGROUND_SERVER_PORT;
const errorHandler = (err, req, res, next)=>{
    console.error(err);
    res.status(500).json({
        error: err.message
    });
};
const setup = async ()=>{
    if (!shared_utils_namespaceObject.ifInBrowser && !shared_utils_namespaceObject.ifInWorker) external_dotenv_default().config();
};
class PlaygroundServer {
    filePathForUuid(uuid) {
        return (0, external_node_path_namespaceObject.join)(this.tmpDir, `${uuid}.json`);
    }
    saveContextFile(uuid, context) {
        const tmpFile = this.filePathForUuid(uuid);
        console.log(`save context file: ${tmpFile}`);
        (0, external_node_fs_namespaceObject.writeFileSync)(tmpFile, context);
        return tmpFile;
    }
    async launch(port) {
        this.port = port || defaultPort;
        this.app.use(errorHandler);
        this.app.use(external_cors_default()({
            origin: '*',
            credentials: true
        }));
        this.app.get('/status', async (req, res)=>{
            res.send({
                status: 'ok'
            });
        });
        this.app.get('/context/:uuid', async (req, res)=>{
            const { uuid } = req.params;
            const contextFile = this.filePathForUuid(uuid);
            if (!(0, external_node_fs_namespaceObject.existsSync)(contextFile)) return res.status(404).json({
                error: 'Context not found'
            });
            const context = (0, external_node_fs_namespaceObject.readFileSync)(contextFile, 'utf8');
            res.json({
                context
            });
        });
        this.app.get('/task-progress/:requestId', async (req, res)=>{
            const { requestId } = req.params;
            res.json({
                tip: this.taskProgressTips[requestId] || ''
            });
        });
        this.app.post('/action-space', external_express_default().json({
            limit: '30mb'
        }), async (req, res)=>{
            const { context } = req.body;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            try {
                const page = new this.pageClass(context);
                const actionSpace = await page.actionSpace();
                const processedActionSpace = actionSpace.map((action)=>{
                    if (action.paramSchema && 'object' == typeof action.paramSchema) {
                        let processedSchema = null;
                        try {
                            if (action.paramSchema.shape && 'object' == typeof action.paramSchema.shape) processedSchema = {
                                type: 'ZodObject',
                                shape: action.paramSchema.shape
                            };
                        } catch (e) {
                            console.warn('Failed to process paramSchema for action:', action.name, e);
                        }
                        return {
                            ...action,
                            paramSchema: processedSchema
                        };
                    }
                    return action;
                });
                res.json(processedActionSpace);
            } catch (error) {
                console.error('Failed to get action space:', error);
                res.status(500).json({
                    error: error.message
                });
            }
        });
        this.app.post('/playground-with-context', external_express_default().json({
            limit: '50mb'
        }), async (req, res)=>{
            const context = req.body.context;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            const uuid = (0, external_node_crypto_namespaceObject.randomUUID)();
            this.saveContextFile(uuid, context);
            return res.json({
                location: `/playground/${uuid}`,
                uuid
            });
        });
        this.app.post('/execute', external_express_default().json({
            limit: '30mb'
        }), async (req, res)=>{
            const { context, type, prompt, params, requestId, deepThink, screenshotIncluded, domIncluded } = req.body;
            if (!context) return res.status(400).json({
                error: 'context is required'
            });
            if (!type) return res.status(400).json({
                error: 'type is required'
            });
            const page = new this.pageClass(context);
            const agent = new this.agentClass(page);
            if (requestId) {
                this.taskProgressTips[requestId] = '';
                this.activeAgents[requestId] = agent;
                agent.onTaskStartTip = (tip)=>{
                    this.taskProgressTips[requestId] = tip;
                };
            }
            const response = {
                result: null,
                dump: null,
                error: null,
                reportHTML: null,
                requestId
            };
            const startTime = Date.now();
            try {
                const actionSpace = await page.actionSpace();
                const value = {
                    type,
                    prompt,
                    params
                };
                response.result = await (0, external_common_js_namespaceObject.executeAction)(agent, type, actionSpace, value, {
                    deepThink: deepThink || false,
                    screenshotIncluded,
                    domIncluded
                });
            } catch (error) {
                response.error = (0, external_common_js_namespaceObject.formatErrorMessage)(error);
            }
            try {
                response.dump = JSON.parse(agent.dumpDataString());
                response.reportHTML = agent.reportHTMLString() || null;
                agent.writeOutActionDumps();
                agent.destroy();
            } catch (error) {
                console.error(`write out dump failed: requestId: ${requestId}, ${error.message}`);
            }
            res.send(response);
            const timeCost = Date.now() - startTime;
            if (response.error) console.error(`handle request failed after ${timeCost}ms: requestId: ${requestId}, ${response.error}`);
            else console.log(`handle request done after ${timeCost}ms: requestId: ${requestId}`);
            if (requestId && this.activeAgents[requestId]) delete this.activeAgents[requestId];
        });
        this.app.get('/cancel/:requestId', async (req, res)=>{
            const { requestId } = req.params;
            if (!requestId) return res.status(400).json({
                error: 'requestId is required'
            });
            const agent = this.activeAgents[requestId];
            if (!agent) return res.status(404).json({
                error: 'No active agent found for this requestId'
            });
            try {
                await agent.destroy();
                delete this.activeAgents[requestId];
                res.json({
                    status: 'cancelled'
                });
            } catch (error) {
                console.error(`Failed to cancel agent: ${error.message}`);
                res.status(500).json({
                    error: `Failed to cancel: ${error.message}`
                });
            }
        });
        this.app.post('/config', external_express_default().json({
            limit: '1mb'
        }), async (req, res)=>{
            const { aiConfig } = req.body;
            if (!aiConfig || 'object' != typeof aiConfig) return res.status(400).json({
                error: 'aiConfig is required and must be an object'
            });
            try {
                (0, env_namespaceObject.overrideAIConfig)(aiConfig);
                return res.json({
                    status: 'ok',
                    message: 'AI config updated successfully'
                });
            } catch (error) {
                console.error(`Failed to update AI config: ${error.message}`);
                return res.status(500).json({
                    error: `Failed to update AI config: ${error.message}`
                });
            }
        });
        if (this.staticPath) {
            this.app.get('/', (_req, res)=>{
                res.redirect('/index.html');
            });
            this.app.get('*', (req, res)=>{
                const requestedPath = (0, external_node_path_namespaceObject.join)(this.staticPath, req.path);
                if ((0, external_node_fs_namespaceObject.existsSync)(requestedPath)) res.sendFile(requestedPath);
                else res.sendFile((0, external_node_path_namespaceObject.join)(this.staticPath, 'index.html'));
            });
        }
        return new Promise((resolve)=>{
            const port = this.port;
            this.server = this.app.listen(port, ()=>{
                resolve(this);
            });
        });
    }
    close() {
        if (this.server) return this.server.close();
    }
    constructor(pageClass, agentClass, staticPath){
        _define_property(this, "app", void 0);
        _define_property(this, "tmpDir", void 0);
        _define_property(this, "server", void 0);
        _define_property(this, "port", void 0);
        _define_property(this, "pageClass", void 0);
        _define_property(this, "agentClass", void 0);
        _define_property(this, "staticPath", void 0);
        _define_property(this, "taskProgressTips", void 0);
        _define_property(this, "activeAgents", void 0);
        this.app = external_express_default()();
        this.tmpDir = (0, utils_namespaceObject.getTmpDir)();
        this.pageClass = pageClass;
        this.agentClass = agentClass;
        this.staticPath = staticPath;
        this.taskProgressTips = {};
        this.activeAgents = {};
        setup();
    }
}
exports["default"] = __webpack_exports__["default"];
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "default"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=server.js.map