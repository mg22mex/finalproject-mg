import node_assert from "node:assert";
import { randomUUID } from "node:crypto";
import node_fs from "node:fs";
import { createRequire } from "node:module";
import node_path from "node:path";
import { getMidsceneLocationSchema, z } from "@midscene/core";
import { defineAction, defineActionDragAndDrop, defineActionKeyboardPress, defineActionScroll, defineActionTap } from "@midscene/core/device";
import { getTmpFile, sleep } from "@midscene/core/utils";
import { MIDSCENE_ADB_PATH, MIDSCENE_ADB_REMOTE_HOST, MIDSCENE_ADB_REMOTE_PORT, MIDSCENE_ANDROID_IME_STRATEGY, globalConfigManager, overrideAIConfig, vlLocateMode } from "@midscene/shared/env";
import { createImgBase64ByFormat, isValidPNGImageBuffer, resizeAndConvertImgBuffer } from "@midscene/shared/img";
import { getDebug } from "@midscene/shared/logger";
import { repeat } from "@midscene/shared/utils";
import { ADB } from "appium-adb";
import { Agent } from "@midscene/core/agent";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const defaultScrollUntilTimes = 10;
const defaultFastScrollDuration = 100;
const defaultNormalScrollDuration = 1000;
const debugDevice = getDebug('android:device');
class AndroidDevice {
    actionSpace() {
        return [
            defineActionTap(async (param)=>{
                const element = param.locate;
                node_assert(element, 'Element not found, cannot tap');
                await this.mouseClick(element.center[0], element.center[1]);
            }),
            defineAction({
                name: 'Input',
                description: 'Input text into the input field',
                interfaceAlias: 'aiInput',
                paramSchema: z.object({
                    value: z.string().describe('The final that should be filled in the input box. No matter what modifications are required, just provide the final value to replace the existing input value. Giving a blank string means clear the input field.'),
                    autoDismissKeyboard: z.boolean().optional().describe('If true, the keyboard will be dismissed after the input is completed. Do not set it unless the user asks you to do so.'),
                    locate: getMidsceneLocationSchema().describe('The input field to be filled').optional()
                }),
                call: async (param)=>{
                    var _this_options;
                    const element = param.locate;
                    if (element) {
                        await this.clearInput(element);
                        if (!param || !param.value) return;
                    }
                    const autoDismissKeyboard = param.autoDismissKeyboard ?? (null == (_this_options = this.options) ? void 0 : _this_options.autoDismissKeyboard);
                    await this.keyboardType(param.value, {
                        autoDismissKeyboard
                    });
                }
            }),
            defineActionScroll(async (param)=>{
                const element = param.locate;
                const startingPoint = element ? {
                    left: element.center[0],
                    top: element.center[1]
                } : void 0;
                const scrollToEventName = null == param ? void 0 : param.scrollType;
                if ('untilTop' === scrollToEventName) await this.scrollUntilTop(startingPoint);
                else if ('untilBottom' === scrollToEventName) await this.scrollUntilBottom(startingPoint);
                else if ('untilRight' === scrollToEventName) await this.scrollUntilRight(startingPoint);
                else if ('untilLeft' === scrollToEventName) await this.scrollUntilLeft(startingPoint);
                else if ('once' !== scrollToEventName && scrollToEventName) throw new Error(`Unknown scroll event type: ${scrollToEventName}, param: ${JSON.stringify(param)}`);
                else {
                    if ((null == param ? void 0 : param.direction) !== 'down' && param && param.direction) if ('up' === param.direction) await this.scrollUp(param.distance || void 0, startingPoint);
                    else if ('left' === param.direction) await this.scrollLeft(param.distance || void 0, startingPoint);
                    else if ('right' === param.direction) await this.scrollRight(param.distance || void 0, startingPoint);
                    else throw new Error(`Unknown scroll direction: ${param.direction}`);
                    else await this.scrollDown((null == param ? void 0 : param.distance) || void 0, startingPoint);
                    await sleep(500);
                }
            }),
            defineActionDragAndDrop(async (param)=>{
                const from = param.from;
                const to = param.to;
                node_assert(from, 'missing "from" param for drag and drop');
                node_assert(to, 'missing "to" param for drag and drop');
                await this.mouseDrag({
                    x: from.center[0],
                    y: from.center[1]
                }, {
                    x: to.center[0],
                    y: to.center[1]
                });
            }),
            defineActionKeyboardPress(async (param)=>{
                const key = param.keyName;
                await this.keyboardPress(key);
            }),
            defineAction({
                name: 'AndroidBackButton',
                description: 'Trigger the system "back" operation on Android devices',
                paramSchema: z.object({}),
                call: async ()=>{
                    await this.back();
                }
            }),
            defineAction({
                name: 'AndroidHomeButton',
                description: 'Trigger the system "home" operation on Android devices',
                paramSchema: z.object({}),
                call: async ()=>{
                    await this.home();
                }
            }),
            defineAction({
                name: 'AndroidRecentAppsButton',
                description: 'Trigger the system "recent apps" operation on Android devices',
                paramSchema: z.object({}),
                call: async ()=>{
                    await this.recentApps();
                }
            }),
            defineAction({
                name: 'AndroidLongPress',
                description: 'Trigger a long press on the screen at specified coordinates on Android devices',
                paramSchema: z.object({
                    duration: z.number().optional().describe('The duration of the long press in milliseconds'),
                    locate: getMidsceneLocationSchema().describe('The element to be long pressed')
                }),
                call: async (param)=>{
                    const element = param.locate;
                    if (!element) throw new Error('AndroidLongPress requires an element to be located');
                    const [x, y] = element.center;
                    await this.longPress(x, y, null == param ? void 0 : param.duration);
                }
            }),
            defineAction({
                name: 'AndroidPull',
                description: 'Trigger pull down to refresh or pull up actions',
                paramSchema: z.object({
                    direction: z["enum"]([
                        'up',
                        'down'
                    ]).describe('The direction to pull'),
                    distance: z.number().optional().describe('The distance to pull (in pixels)'),
                    duration: z.number().optional().describe('The duration of the pull (in milliseconds)'),
                    locate: getMidsceneLocationSchema().optional().describe('The element to start the pull from (optional)')
                }),
                call: async (param)=>{
                    const element = param.locate;
                    const startPoint = element ? {
                        left: element.center[0],
                        top: element.center[1]
                    } : void 0;
                    if (!param || !param.direction) throw new Error('AndroidPull requires a direction parameter');
                    if ('down' === param.direction) await this.pullDown(startPoint, param.distance, param.duration);
                    else if ('up' === param.direction) await this.pullUp(startPoint, param.distance, param.duration);
                    else throw new Error(`Unknown pull direction: ${param.direction}`);
                }
            })
        ];
    }
    describe() {
        return this.description || `DeviceId: ${this.deviceId}`;
    }
    async connect() {
        return this.getAdb();
    }
    async getAdb() {
        if (this.destroyed) throw new Error(`AndroidDevice ${this.deviceId} has been destroyed and cannot execute ADB commands`);
        if (this.adb) return this.createAdbProxy(this.adb);
        if (this.connectingAdb) return this.connectingAdb.then((adb)=>this.createAdbProxy(adb));
        this.connectingAdb = (async ()=>{
            let error = null;
            debugDevice(`Initializing ADB with device ID: ${this.deviceId}`);
            try {
                var _this_options, _this_options1, _this_options2;
                const androidAdbPath = (null == (_this_options = this.options) ? void 0 : _this_options.androidAdbPath) || globalConfigManager.getEnvConfigValue(MIDSCENE_ADB_PATH);
                const remoteAdbHost = (null == (_this_options1 = this.options) ? void 0 : _this_options1.remoteAdbHost) || globalConfigManager.getEnvConfigValue(MIDSCENE_ADB_REMOTE_HOST);
                const remoteAdbPort = (null == (_this_options2 = this.options) ? void 0 : _this_options2.remoteAdbPort) || globalConfigManager.getEnvConfigValue(MIDSCENE_ADB_REMOTE_PORT);
                this.adb = await new ADB({
                    udid: this.deviceId,
                    adbExecTimeout: 60000,
                    executable: androidAdbPath ? {
                        path: androidAdbPath,
                        defaultArgs: []
                    } : void 0,
                    remoteAdbHost: remoteAdbHost || void 0,
                    remoteAdbPort: remoteAdbPort ? Number(remoteAdbPort) : void 0
                });
                const size = await this.getScreenSize();
                this.description = `
DeviceId: ${this.deviceId}
ScreenSize:
${Object.keys(size).filter((key)=>size[key]).map((key)=>`  ${key} size: ${size[key]}${'override' === key && size[key] ? " \u2705" : ''}`).join('\n')}
`;
                debugDevice('ADB initialized successfully', this.description);
                return this.adb;
            } catch (e) {
                debugDevice(`Failed to initialize ADB: ${e}`);
                error = new Error(`Unable to connect to device ${this.deviceId}: ${e}`);
            } finally{
                this.connectingAdb = null;
            }
            if (error) throw error;
            throw new Error('ADB initialization failed unexpectedly');
        })();
        return this.connectingAdb;
    }
    createAdbProxy(adb) {
        return new Proxy(adb, {
            get: (target, prop)=>{
                const originalMethod = target[prop];
                if ('function' != typeof originalMethod) return originalMethod;
                return async (...args)=>{
                    try {
                        debugDevice(`adb ${String(prop)} ${args.join(' ')}`);
                        const result = await originalMethod.apply(target, args);
                        debugDevice(`adb ${String(prop)} ${args.join(' ')} end`);
                        return result;
                    } catch (error) {
                        const methodName = String(prop);
                        const deviceId = this.deviceId;
                        debugDevice(`ADB error with device ${deviceId} when calling ${methodName}: ${error}`);
                        throw new Error(`ADB error with device ${deviceId} when calling ${methodName}, please check https://midscenejs.com/integrate-with-android.html#faq : ${error.message}`, {
                            cause: error
                        });
                    }
                };
            }
        });
    }
    async launch(uri) {
        const adb = await this.getAdb();
        this.uri = uri;
        try {
            debugDevice(`Launching app: ${uri}`);
            if (uri.startsWith('http://') || uri.startsWith('https://') || uri.includes('://')) await adb.startUri(uri);
            else if (uri.includes('/')) {
                const [appPackage, appActivity] = uri.split('/');
                await adb.startApp({
                    pkg: appPackage,
                    activity: appActivity
                });
            } else await adb.activateApp(uri);
            debugDevice(`Successfully launched: ${uri}`);
        } catch (error) {
            debugDevice(`Error launching ${uri}: ${error}`);
            throw new Error(`Failed to launch ${uri}: ${error.message}`, {
                cause: error
            });
        }
        return this;
    }
    async execYadb(keyboardContent) {
        await this.ensureYadb();
        const adb = await this.getAdb();
        await adb.shell(`app_process${this.getDisplayArg()} -Djava.class.path=/data/local/tmp/yadb /data/local/tmp com.ysbing.yadb.Main -keyboard "${keyboardContent}"`);
    }
    async getElementsInfo() {
        return [];
    }
    async getElementsNodeTree() {
        return {
            node: null,
            children: []
        };
    }
    async getScreenSize() {
        var _this_options;
        const adb = await this.getAdb();
        if ('number' == typeof (null == (_this_options = this.options) ? void 0 : _this_options.displayId)) try {
            var _this_options1;
            const stdout = await adb.shell('dumpsys display');
            if (null == (_this_options1 = this.options) ? void 0 : _this_options1.usePhysicalDisplayIdForDisplayLookup) {
                const physicalDisplayId = await this.getPhysicalDisplayId();
                if (physicalDisplayId) {
                    const lineRegex = new RegExp(`^.*uniqueId \"local:${physicalDisplayId}\".*$
`, 'm');
                    const lineMatch = stdout.match(lineRegex);
                    if (lineMatch) {
                        const targetLine = lineMatch[0];
                        const realMatch = targetLine.match(/real (\d+) x (\d+)/);
                        const rotationMatch = targetLine.match(/rotation (\d+)/);
                        if (realMatch && rotationMatch) {
                            const width = Number(realMatch[1]);
                            const height = Number(realMatch[2]);
                            const rotation = Number(rotationMatch[1]);
                            const sizeStr = `${width}x${height}`;
                            debugDevice(`Using display info for long ID ${physicalDisplayId}: ${sizeStr}, rotation: ${rotation}`);
                            return {
                                override: sizeStr,
                                physical: sizeStr,
                                orientation: rotation
                            };
                        }
                    }
                }
            } else {
                const viewportRegex = new RegExp(`DisplayViewport{[^}]*displayId=${this.options.displayId}[^}]*}`, 'g');
                const match = stdout.match(viewportRegex);
                if (match) {
                    const targetLine = match[0];
                    const physicalFrameMatch = targetLine.match(/physicalFrame=Rect\(\d+, \d+ - (\d+), (\d+)\)/);
                    const orientationMatch = targetLine.match(/orientation=(\d+)/);
                    if (physicalFrameMatch && orientationMatch) {
                        const width = Number(physicalFrameMatch[1]);
                        const height = Number(physicalFrameMatch[2]);
                        const rotation = Number(orientationMatch[1]);
                        const sizeStr = `${width}x${height}`;
                        debugDevice(`Using display info for display ID ${this.options.displayId}: ${sizeStr}, rotation: ${rotation}`);
                        return {
                            override: sizeStr,
                            physical: sizeStr,
                            orientation: rotation
                        };
                    }
                }
            }
            debugDevice(`Could not find display info for displayId ${this.options.displayId}`);
        } catch (e) {
            debugDevice(`Failed to get size from display info for display ${this.options.displayId}: ${e}`);
        }
        const stdout = await adb.shell([
            'wm',
            'size'
        ]);
        const size = {
            override: '',
            physical: ''
        };
        const overrideSize = new RegExp(/Override size: ([^\r?\n]+)*/g).exec(stdout);
        if (overrideSize && overrideSize.length >= 2 && overrideSize[1]) {
            debugDevice(`Using Override size: ${overrideSize[1].trim()}`);
            size.override = overrideSize[1].trim();
        }
        const physicalSize = new RegExp(/Physical size: ([^\r?\n]+)*/g).exec(stdout);
        if (physicalSize && physicalSize.length >= 2) {
            debugDevice(`Using Physical size: ${physicalSize[1].trim()}`);
            size.physical = physicalSize[1].trim();
        }
        const orientation = await this.getDisplayOrientation();
        if (size.override || size.physical) return {
            ...size,
            orientation
        };
        throw new Error(`Failed to get screen size, output: ${stdout}`);
    }
    async getDisplayDensity() {
        var _this_options;
        const adb = await this.getAdb();
        if ('number' == typeof (null == (_this_options = this.options) ? void 0 : _this_options.displayId)) try {
            var _this_options1;
            const stdout = await adb.shell('dumpsys display');
            if (null == (_this_options1 = this.options) ? void 0 : _this_options1.usePhysicalDisplayIdForDisplayLookup) {
                const physicalDisplayId = await this.getPhysicalDisplayId();
                if (physicalDisplayId) {
                    const lineRegex = new RegExp(`^.*uniqueId \"local:${physicalDisplayId}\".*$
`, 'm');
                    const lineMatch = stdout.match(lineRegex);
                    if (lineMatch) {
                        const targetLine = lineMatch[0];
                        const densityMatch = targetLine.match(/density (\d+)/);
                        if (densityMatch) {
                            const density = Number(densityMatch[1]);
                            debugDevice(`Using display density for physical ID ${physicalDisplayId}: ${density}`);
                            return density;
                        }
                    }
                }
            } else {
                const displayDeviceRegex = new RegExp(`DisplayDevice:[\\s\\S]*?mDisplayId=${this.options.displayId}[\\s\\S]*?DisplayInfo{[^}]*density (\\d+)`, 'm');
                const deviceBlockMatch = stdout.match(displayDeviceRegex);
                if (deviceBlockMatch) {
                    const density = Number(deviceBlockMatch[1]);
                    debugDevice(`Using display density for display ID ${this.options.displayId}: ${density}`);
                    return density;
                }
            }
        } catch (e) {
            debugDevice(`Failed to get density from display info: ${e}`);
        }
        const density = await adb.getScreenDensity();
        return density ?? 160;
    }
    async getDisplayOrientation() {
        const adb = await this.getAdb();
        let orientation = 0;
        try {
            const orientationStdout = await adb.shell(`dumpsys${this.getDisplayArg()} input | grep SurfaceOrientation`);
            const orientationMatch = orientationStdout.match(/SurfaceOrientation:\s*(\d)/);
            if (!orientationMatch) throw new Error('Failed to get orientation from input');
            orientation = Number(orientationMatch[1]);
            debugDevice(`Screen orientation: ${orientation}`);
        } catch (e) {
            debugDevice('Failed to get orientation from input, try display');
            try {
                const orientationStdout = await adb.shell(`dumpsys${this.getDisplayArg()} display | grep mCurrentOrientation`);
                const orientationMatch = orientationStdout.match(/mCurrentOrientation=(\d)/);
                if (!orientationMatch) throw new Error('Failed to get orientation from display');
                orientation = Number(orientationMatch[1]);
                debugDevice(`Screen orientation (fallback): ${orientation}`);
            } catch (e2) {
                orientation = 0;
                debugDevice('Failed to get orientation from display, default to 0');
            }
        }
        return orientation;
    }
    async size() {
        await this.getAdb();
        const screenSize = await this.getScreenSize();
        const match = (screenSize.override || screenSize.physical).match(/(\d+)x(\d+)/);
        if (!match || match.length < 3) throw new Error(`Unable to parse screen size: ${screenSize}`);
        const isLandscape = 1 === screenSize.orientation || 3 === screenSize.orientation;
        const width = Number.parseInt(match[isLandscape ? 2 : 1], 10);
        const height = Number.parseInt(match[isLandscape ? 1 : 2], 10);
        const densityNum = await this.getDisplayDensity();
        this.devicePixelRatio = Number(densityNum) / 160;
        const { x: logicalWidth, y: logicalHeight } = this.reverseAdjustCoordinates(width, height);
        return {
            width: logicalWidth,
            height: logicalHeight,
            dpr: this.devicePixelRatio
        };
    }
    adjustCoordinates(x, y) {
        const ratio = this.devicePixelRatio;
        return {
            x: Math.round(x * ratio),
            y: Math.round(y * ratio)
        };
    }
    reverseAdjustCoordinates(x, y) {
        const ratio = this.devicePixelRatio;
        return {
            x: Math.round(x / ratio),
            y: Math.round(y / ratio)
        };
    }
    async screenshotBase64() {
        var _this_options;
        debugDevice('screenshotBase64 begin');
        const { width, height } = await this.size();
        const adb = await this.getAdb();
        let screenshotBuffer;
        const androidScreenshotPath = `/data/local/tmp/midscene_screenshot_${randomUUID()}.png`;
        const useShellScreencap = 'number' == typeof (null == (_this_options = this.options) ? void 0 : _this_options.displayId);
        try {
            if (useShellScreencap) {
                var _this_options1;
                throw new Error(`Display ${null == (_this_options1 = this.options) ? void 0 : _this_options1.displayId} requires shell screencap`);
            }
            debugDevice('Taking screenshot via adb.takeScreenshot');
            screenshotBuffer = await adb.takeScreenshot(null);
            debugDevice('adb.takeScreenshot completed');
            if (!screenshotBuffer) throw new Error('Failed to capture screenshot: screenshotBuffer is null');
            if (!isValidPNGImageBuffer(screenshotBuffer)) {
                debugDevice('Invalid image buffer detected: not a valid image format');
                throw new Error('Screenshot buffer has invalid format: could not find valid image signature');
            }
        } catch (error) {
            debugDevice(`Taking screenshot via adb.takeScreenshot failed or was skipped: ${error}`);
            const screenshotPath = getTmpFile('png');
            try {
                var _this_options2, _this_options3;
                debugDevice('Fallback: taking screenshot via shell screencap');
                const displayId = (null == (_this_options2 = this.options) ? void 0 : _this_options2.usePhysicalDisplayIdForScreenshot) ? await this.getPhysicalDisplayId() : null == (_this_options3 = this.options) ? void 0 : _this_options3.displayId;
                const displayArg = displayId ? `-d ${displayId}` : '';
                try {
                    await adb.shell(`screencap -p ${displayArg} ${androidScreenshotPath}`.trim());
                    debugDevice('adb.shell screencap completed');
                } catch (screencapError) {
                    debugDevice('screencap failed, using forceScreenshot');
                    await this.forceScreenshot(androidScreenshotPath);
                    debugDevice('forceScreenshot completed');
                }
                debugDevice('Pulling screenshot file from device');
                await adb.pull(androidScreenshotPath, screenshotPath);
                debugDevice(`adb.pull completed, local path: ${screenshotPath}`);
                screenshotBuffer = await node_fs.promises.readFile(screenshotPath);
            } finally{
                await adb.shell(`rm ${androidScreenshotPath}`);
            }
        }
        debugDevice('Resizing screenshot image');
        const { buffer, format } = await resizeAndConvertImgBuffer('png', screenshotBuffer, {
            width,
            height
        });
        debugDevice('Image resize completed');
        debugDevice('Converting to base64');
        const result = createImgBase64ByFormat(format, buffer.toString('base64'));
        debugDevice('screenshotBase64 end');
        return result;
    }
    async clearInput(element) {
        if (!element) return;
        await this.ensureYadb();
        const adb = await this.getAdb();
        await this.mouseClick(element.center[0], element.center[1]);
        await adb.shell(`app_process${this.getDisplayArg()} -Djava.class.path=/data/local/tmp/yadb /data/local/tmp com.ysbing.yadb.Main -keyboard "~CLEAR~"`);
        if (await adb.isSoftKeyboardPresent()) return;
        await this.mouseClick(element.center[0], element.center[1]);
    }
    async forceScreenshot(path) {
        await this.ensureYadb();
        const adb = await this.getAdb();
        await adb.shell(`app_process -Djava.class.path=/data/local/tmp/yadb /data/local/tmp com.ysbing.yadb.Main -screenshot ${path}`);
    }
    async url() {
        return '';
    }
    async scrollUntilTop(startPoint) {
        if (startPoint) {
            const { height } = await this.size();
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const end = {
                x: start.x,
                y: height
            };
            await repeat(defaultScrollUntilTimes, ()=>this.mouseDrag(start, end, defaultFastScrollDuration));
            await sleep(1000);
            return;
        }
        await repeat(defaultScrollUntilTimes, ()=>this.scroll(0, -9999999, defaultFastScrollDuration));
        await sleep(1000);
    }
    async scrollUntilBottom(startPoint) {
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const end = {
                x: start.x,
                y: 0
            };
            await repeat(defaultScrollUntilTimes, ()=>this.mouseDrag(start, end, defaultFastScrollDuration));
            await sleep(1000);
            return;
        }
        await repeat(defaultScrollUntilTimes, ()=>this.scroll(0, 9999999, defaultFastScrollDuration));
        await sleep(1000);
    }
    async scrollUntilLeft(startPoint) {
        if (startPoint) {
            const { width } = await this.size();
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const end = {
                x: width,
                y: start.y
            };
            await repeat(defaultScrollUntilTimes, ()=>this.mouseDrag(start, end, defaultFastScrollDuration));
            await sleep(1000);
            return;
        }
        await repeat(defaultScrollUntilTimes, ()=>this.scroll(-9999999, 0, defaultFastScrollDuration));
        await sleep(1000);
    }
    async scrollUntilRight(startPoint) {
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const end = {
                x: 0,
                y: start.y
            };
            await repeat(defaultScrollUntilTimes, ()=>this.mouseDrag(start, end, defaultFastScrollDuration));
            await sleep(1000);
            return;
        }
        await repeat(defaultScrollUntilTimes, ()=>this.scroll(9999999, 0, defaultFastScrollDuration));
        await sleep(1000);
    }
    async scrollUp(distance, startPoint) {
        const { height } = await this.size();
        const scrollDistance = distance || height;
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const endY = Math.min(height, start.y + scrollDistance);
            const end = {
                x: start.x,
                y: endY
            };
            await this.mouseDrag(start, end);
            return;
        }
        await this.scroll(0, -scrollDistance);
    }
    async scrollDown(distance, startPoint) {
        const { height } = await this.size();
        const scrollDistance = distance || height;
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const endY = Math.max(0, start.y - scrollDistance);
            const end = {
                x: start.x,
                y: endY
            };
            await this.mouseDrag(start, end);
            return;
        }
        await this.scroll(0, scrollDistance);
    }
    async scrollLeft(distance, startPoint) {
        const { width } = await this.size();
        const scrollDistance = distance || width;
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const endX = Math.min(width, start.x + scrollDistance);
            const end = {
                x: endX,
                y: start.y
            };
            await this.mouseDrag(start, end);
            return;
        }
        await this.scroll(-scrollDistance, 0);
    }
    async scrollRight(distance, startPoint) {
        const { width } = await this.size();
        const scrollDistance = distance || width;
        if (startPoint) {
            const start = {
                x: startPoint.left,
                y: startPoint.top
            };
            const endX = Math.max(0, start.x - scrollDistance);
            const end = {
                x: endX,
                y: start.y
            };
            await this.mouseDrag(start, end);
            return;
        }
        await this.scroll(scrollDistance, 0);
    }
    async ensureYadb() {
        if (!this.yadbPushed) {
            const adb = await this.getAdb();
            const androidPkgJson = createRequire(import.meta.url).resolve('@midscene/android/package.json');
            const yadbBin = node_path.join(node_path.dirname(androidPkgJson), 'bin', 'yadb');
            await adb.push(yadbBin, '/data/local/tmp');
            this.yadbPushed = true;
        }
    }
    async keyboardType(text, options) {
        var _this_options, _this_options1;
        if (!text) return;
        const adb = await this.getAdb();
        const isChinese = /[\p{Script=Han}\p{sc=Hani}]/u.test(text);
        const IME_STRATEGY = ((null == (_this_options = this.options) ? void 0 : _this_options.imeStrategy) || globalConfigManager.getEnvConfigValue(MIDSCENE_ANDROID_IME_STRATEGY)) ?? 'always-yadb';
        const shouldAutoDismissKeyboard = (null == options ? void 0 : options.autoDismissKeyboard) ?? (null == (_this_options1 = this.options) ? void 0 : _this_options1.autoDismissKeyboard) ?? true;
        if ('always-yadb' === IME_STRATEGY || 'yadb-for-non-ascii' === IME_STRATEGY && isChinese) await this.execYadb(text);
        else await adb.inputText(text);
        if (true === shouldAutoDismissKeyboard) await this.hideKeyboard(options);
    }
    normalizeKeyName(key) {
        const keyMap = {
            enter: 'Enter',
            backspace: 'Backspace',
            tab: 'Tab',
            escape: 'Escape',
            esc: 'Escape',
            home: 'Home',
            end: 'End',
            arrowup: 'ArrowUp',
            arrowdown: 'ArrowDown',
            arrowleft: 'ArrowLeft',
            arrowright: 'ArrowRight',
            up: 'ArrowUp',
            down: 'ArrowDown',
            left: 'ArrowLeft',
            right: 'ArrowRight'
        };
        const lowerKey = key.toLowerCase();
        return keyMap[lowerKey] || key;
    }
    async keyboardPress(key) {
        const keyCodeMap = {
            Enter: 66,
            Backspace: 67,
            Tab: 61,
            ArrowUp: 19,
            ArrowDown: 20,
            ArrowLeft: 21,
            ArrowRight: 22,
            Escape: 111,
            Home: 3,
            End: 123
        };
        const adb = await this.getAdb();
        const normalizedKey = this.normalizeKeyName(key);
        const keyCode = keyCodeMap[normalizedKey];
        if (void 0 !== keyCode) await adb.keyevent(keyCode);
        else if (1 === key.length) {
            const asciiCode = key.toUpperCase().charCodeAt(0);
            if (asciiCode >= 65 && asciiCode <= 90) await adb.keyevent(asciiCode - 36);
        }
    }
    async mouseClick(x, y) {
        const adb = await this.getAdb();
        const { x: adjustedX, y: adjustedY } = this.adjustCoordinates(x, y);
        await adb.shell(`input${this.getDisplayArg()} swipe ${adjustedX} ${adjustedY} ${adjustedX} ${adjustedY} 150`);
    }
    async mouseMove(x, y) {
        return Promise.resolve();
    }
    async mouseDrag(from, to, duration) {
        const adb = await this.getAdb();
        const { x: fromX, y: fromY } = this.adjustCoordinates(from.x, from.y);
        const { x: toX, y: toY } = this.adjustCoordinates(to.x, to.y);
        const swipeDuration = duration ?? 300;
        await adb.shell(`input${this.getDisplayArg()} swipe ${fromX} ${fromY} ${toX} ${toY} ${swipeDuration}`);
    }
    async scroll(deltaX, deltaY, duration) {
        const { width, height } = await this.size();
        const n = 4;
        const startX = deltaX < 0 ? width / n * (n - 1) : width / n;
        const startY = deltaY < 0 ? height / n * (n - 1) : height / n;
        const maxNegativeDeltaX = startX;
        const maxPositiveDeltaX = width / n * (n - 1);
        const maxNegativeDeltaY = startY;
        const maxPositiveDeltaY = height / n * (n - 1);
        deltaX = Math.max(-maxNegativeDeltaX, Math.min(deltaX, maxPositiveDeltaX));
        deltaY = Math.max(-maxNegativeDeltaY, Math.min(deltaY, maxPositiveDeltaY));
        const endX = startX - deltaX;
        const endY = startY - deltaY;
        const { x: adjustedStartX, y: adjustedStartY } = this.adjustCoordinates(startX, startY);
        const { x: adjustedEndX, y: adjustedEndY } = this.adjustCoordinates(endX, endY);
        const adb = await this.getAdb();
        const swipeDuration = duration ?? defaultNormalScrollDuration;
        await adb.shell(`input${this.getDisplayArg()} swipe ${adjustedStartX} ${adjustedStartY} ${adjustedEndX} ${adjustedEndY} ${swipeDuration}`);
    }
    async destroy() {
        if (this.destroyed) return;
        this.destroyed = true;
        try {
            if (this.adb) this.adb = null;
        } catch (error) {
            console.error('Error during cleanup:', error);
        }
        this.connectingAdb = null;
        this.yadbPushed = false;
    }
    async back() {
        const adb = await this.getAdb();
        await adb.shell(`input${this.getDisplayArg()} keyevent 4`);
    }
    async home() {
        const adb = await this.getAdb();
        await adb.shell(`input${this.getDisplayArg()} keyevent 3`);
    }
    async recentApps() {
        const adb = await this.getAdb();
        await adb.shell(`input${this.getDisplayArg()} keyevent 187`);
    }
    async longPress(x, y, duration = 1000) {
        const adb = await this.getAdb();
        const { x: adjustedX, y: adjustedY } = this.adjustCoordinates(x, y);
        await adb.shell(`input${this.getDisplayArg()} swipe ${adjustedX} ${adjustedY} ${adjustedX} ${adjustedY} ${duration}`);
    }
    async pullDown(startPoint, distance, duration = 800) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: startPoint.left,
            y: startPoint.top
        } : {
            x: width / 2,
            y: 0.15 * height
        };
        const pullDistance = distance || 0.5 * height;
        const end = {
            x: start.x,
            y: start.y + pullDistance
        };
        await this.pullDrag(start, end, duration);
        await sleep(200);
    }
    async pullDrag(from, to, duration) {
        const adb = await this.getAdb();
        const { x: fromX, y: fromY } = this.adjustCoordinates(from.x, from.y);
        const { x: toX, y: toY } = this.adjustCoordinates(to.x, to.y);
        await adb.shell(`input${this.getDisplayArg()} swipe ${fromX} ${fromY} ${toX} ${toY} ${duration}`);
    }
    async pullUp(startPoint, distance, duration = 600) {
        const { width, height } = await this.size();
        const start = startPoint ? {
            x: startPoint.left,
            y: startPoint.top
        } : {
            x: width / 2,
            y: 0.85 * height
        };
        const pullDistance = distance || 0.4 * height;
        const end = {
            x: start.x,
            y: start.y - pullDistance
        };
        await this.pullDrag(start, end, duration);
        await sleep(100);
    }
    async getXpathsById(id) {
        throw new Error('Not implemented');
    }
    async getXpathsByPoint(point, isOrderSensitive) {
        throw new Error('Not implemented');
    }
    async getElementInfoByXpath(xpath) {
        throw new Error('Not implemented');
    }
    getDisplayArg() {
        var _this_options;
        return 'number' == typeof (null == (_this_options = this.options) ? void 0 : _this_options.displayId) ? ` -d ${this.options.displayId}` : '';
    }
    async getPhysicalDisplayId() {
        var _this_options;
        if ('number' != typeof (null == (_this_options = this.options) ? void 0 : _this_options.displayId)) return null;
        const adb = await this.getAdb();
        try {
            const stdout = await adb.shell(`dumpsys SurfaceFlinger --display-id ${this.options.displayId}`);
            const regex = new RegExp(`Display (\\d+) \\(HWC display ${this.options.displayId}\\):`);
            const displayMatch = stdout.match(regex);
            if (null == displayMatch ? void 0 : displayMatch[1]) {
                debugDevice(`Found physical display ID: ${displayMatch[1]} for display ID: ${this.options.displayId}`);
                return displayMatch[1];
            }
            debugDevice(`Could not find physical display ID for display ID: ${this.options.displayId}`);
            return null;
        } catch (error) {
            debugDevice(`Error getting physical display ID: ${error}`);
            return null;
        }
    }
    async hideKeyboard(options, timeoutMs = 1000) {
        var _this_options;
        const adb = await this.getAdb();
        const keyboardDismissStrategy = (null == options ? void 0 : options.keyboardDismissStrategy) ?? (null == (_this_options = this.options) ? void 0 : _this_options.keyboardDismissStrategy) ?? 'esc-first';
        const keyboardStatus = await adb.isSoftKeyboardPresent();
        const isKeyboardShown = 'boolean' == typeof keyboardStatus ? keyboardStatus : null == keyboardStatus ? void 0 : keyboardStatus.isKeyboardShown;
        if (!isKeyboardShown) {
            debugDevice('Keyboard has no UI; no closing necessary');
            return false;
        }
        const keyCodes = 'back-first' === keyboardDismissStrategy ? [
            4,
            111
        ] : [
            111,
            4
        ];
        for (const keyCode of keyCodes){
            await adb.keyevent(keyCode);
            const startTime = Date.now();
            const intervalMs = 100;
            while(Date.now() - startTime < timeoutMs){
                await sleep(intervalMs);
                const currentStatus = await adb.isSoftKeyboardPresent();
                const isStillShown = 'boolean' == typeof currentStatus ? currentStatus : null == currentStatus ? void 0 : currentStatus.isKeyboardShown;
                if (!isStillShown) {
                    debugDevice(`Keyboard hidden successfully with keycode ${keyCode}`);
                    return true;
                }
            }
            debugDevice(`Keyboard still shown after keycode ${keyCode}, trying next key`);
        }
        console.warn('Warning: Failed to hide the software keyboard after trying both ESC and BACK keys');
        return false;
    }
    constructor(deviceId, options){
        _define_property(this, "deviceId", void 0);
        _define_property(this, "yadbPushed", false);
        _define_property(this, "devicePixelRatio", 1);
        _define_property(this, "adb", null);
        _define_property(this, "connectingAdb", null);
        _define_property(this, "destroyed", false);
        _define_property(this, "description", void 0);
        _define_property(this, "interfaceType", 'android');
        _define_property(this, "uri", void 0);
        _define_property(this, "options", void 0);
        node_assert(deviceId, 'deviceId is required for AndroidDevice');
        this.deviceId = deviceId;
        this.options = options;
    }
}
const debugUtils = getDebug('android:utils');
async function getConnectedDevices() {
    try {
        const adb = await ADB.createADB({
            adbExecTimeout: 60000
        });
        const devices = await adb.getConnectedDevices();
        debugUtils(`Found ${devices.length} connected devices: `, devices);
        return devices;
    } catch (error) {
        console.error('Failed to get device list:', error);
        throw new Error(`Unable to get connected Android device list, please check https://midscenejs.com/integrate-with-android.html#faq : ${error.message}`, {
            cause: error
        });
    }
}
const debugAgent = getDebug('android:agent');
class AndroidAgent extends Agent {
    async launch(uri) {
        const device = this.page;
        await device.launch(uri);
    }
    constructor(interfaceInstance, opts){
        super(interfaceInstance, opts);
        if (!vlLocateMode({
            intent: 'grounding'
        }) || !vlLocateMode({
            intent: 'planning'
        })) throw new Error('Android Agent only supports vl-model. https://midscenejs.com/choose-a-model.html');
    }
}
async function agentFromAdbDevice(deviceId, opts) {
    if (!deviceId) {
        const devices = await getConnectedDevices();
        deviceId = devices[0].udid;
        debugAgent('deviceId not specified, will use the first device (id = %s)', deviceId);
    }
    const device = new AndroidDevice(deviceId, {
        autoDismissKeyboard: null == opts ? void 0 : opts.autoDismissKeyboard,
        androidAdbPath: null == opts ? void 0 : opts.androidAdbPath,
        remoteAdbHost: null == opts ? void 0 : opts.remoteAdbHost,
        remoteAdbPort: null == opts ? void 0 : opts.remoteAdbPort,
        imeStrategy: null == opts ? void 0 : opts.imeStrategy,
        displayId: null == opts ? void 0 : opts.displayId,
        usePhysicalDisplayIdForScreenshot: null == opts ? void 0 : opts.usePhysicalDisplayIdForScreenshot,
        usePhysicalDisplayIdForDisplayLookup: null == opts ? void 0 : opts.usePhysicalDisplayIdForDisplayLookup
    });
    await device.connect();
    return new AndroidAgent(device, opts);
}
export { AndroidAgent, AndroidDevice, agentFromAdbDevice, getConnectedDevices, overrideAIConfig };
